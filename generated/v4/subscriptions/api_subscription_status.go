/*
Communication Preferences Subscriptions

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v4
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package subscriptions

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/killean-johnson/go-hubspot"
"net/url"
	"strings"
)


// SubscriptionStatusAPIService SubscriptionStatusAPI service
type SubscriptionStatusAPIService service

type ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	subscriberIdString string
	channel *string
	businessUnitId *int64
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest) Channel(channel string) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest {
	r.channel = &channel
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest) BusinessUnitId(businessUnitId int64) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest {
	r.businessUnitId = &businessUnitId
	return r
}

func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest) Execute() (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	return r.ApiService.GetCommunicationPreferencesV4StatusesSubscriberIdStringExecute(r)
}

/*
GetCommunicationPreferencesV4StatusesSubscriberIdString Get subscription preferences for a specific contact

Retrieve a contact's current email subscription preferences.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriberIdString The contact's email address.
 @return ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest
*/
func (a *SubscriptionStatusAPIService) GetCommunicationPreferencesV4StatusesSubscriberIdString(ctx context.Context, subscriberIdString string) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest {
	return ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest{
		ApiService: a,
		ctx: ctx,
		subscriberIdString: subscriberIdString,
	}
}

// Execute executes the request
//  @return ActionResponseWithResultsPublicStatus
func (a *SubscriptionStatusAPIService) GetCommunicationPreferencesV4StatusesSubscriberIdStringExecute(r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringRequest) (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionResponseWithResultsPublicStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.GetCommunicationPreferencesV4StatusesSubscriberIdString")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/{subscriberIdString}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriberIdString"+"}", url.PathEscape(parameterValueToString(r.subscriberIdString, "subscriberIdString")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	subscriberIdString string
	channel *string
	businessUnitId *int64
	verbose *bool
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Channel(channel string) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.channel = &channel
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) BusinessUnitId(businessUnitId int64) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.businessUnitId = &businessUnitId
	return r
}

// Set to &#x60;true&#x60; to include the details of the updated subscription statuses in the response. Not including this parameter will result in an empty response.
func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Verbose(verbose bool) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.verbose = &verbose
	return r
}

func (r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Execute() (*ActionResponseWithResultsPublicWideStatus, *http.Response, error) {
	return r.ApiService.GetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllExecute(r)
}

/*
GetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll Retrieve a contact's unsubscribed status

Check whether a contact has unsubscribed from all email subscriptions. If a contact has not opted out of all communications, the response `results` array will be empty.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriberIdString The contact's email address.
 @return ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest
*/
func (a *SubscriptionStatusAPIService) GetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll(ctx context.Context, subscriberIdString string) ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	return ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest{
		ApiService: a,
		ctx: ctx,
		subscriberIdString: subscriberIdString,
	}
}

// Execute executes the request
//  @return ActionResponseWithResultsPublicWideStatus
func (a *SubscriptionStatusAPIService) GetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllExecute(r ApiGetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) (*ActionResponseWithResultsPublicWideStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionResponseWithResultsPublicWideStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.GetCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/{subscriberIdString}/unsubscribe-all"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriberIdString"+"}", url.PathEscape(parameterValueToString(r.subscriberIdString, "subscriberIdString")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesBatchReadRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	channel *string
	batchInputString *BatchInputString
	businessUnitId *int64
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchReadRequest) Channel(channel string) ApiPostCommunicationPreferencesV4StatusesBatchReadRequest {
	r.channel = &channel
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchReadRequest) BatchInputString(batchInputString BatchInputString) ApiPostCommunicationPreferencesV4StatusesBatchReadRequest {
	r.batchInputString = &batchInputString
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchReadRequest) BusinessUnitId(businessUnitId int64) ApiPostCommunicationPreferencesV4StatusesBatchReadRequest {
	r.businessUnitId = &businessUnitId
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchReadRequest) Execute() (*BatchResponsePublicStatusBulkResponse, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesBatchReadExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesBatchRead Batch retrieve subscription statuses

Batch retrieve subscription statuses for a set of contacts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCommunicationPreferencesV4StatusesBatchReadRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchRead(ctx context.Context) ApiPostCommunicationPreferencesV4StatusesBatchReadRequest {
	return ApiPostCommunicationPreferencesV4StatusesBatchReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicStatusBulkResponse
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchReadExecute(r ApiPostCommunicationPreferencesV4StatusesBatchReadRequest) (*BatchResponsePublicStatusBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicStatusBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesBatchRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	channel *string
	batchInputString *BatchInputString
	businessUnitId *int64
	verbose *bool
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) Channel(channel string) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest {
	r.channel = &channel
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) BatchInputString(batchInputString BatchInputString) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest {
	r.batchInputString = &batchInputString
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) BusinessUnitId(businessUnitId int64) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest {
	r.businessUnitId = &businessUnitId
	return r
}

// Set to &#x60;true&#x60; to include the details of the updated subscription statuses in the response. Not including this parameter will result in an empty response.
func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) Verbose(verbose bool) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest {
	r.verbose = &verbose
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) Execute() (*BatchResponsePublicBulkOptOutFromAllResponse, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesBatchUnsubscribeAll Batch unsubscribe contacts from all subscriptions

Unsubscribe a set of contacts from all email subscriptions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchUnsubscribeAll(ctx context.Context) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest {
	return ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicBulkOptOutFromAllResponse
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllExecute(r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRequest) (*BatchResponsePublicBulkOptOutFromAllResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicBulkOptOutFromAllResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesBatchUnsubscribeAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/batch/unsubscribe-all"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	channel *string
	batchInputString *BatchInputString
	businessUnitId *int64
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest) Channel(channel string) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest {
	r.channel = &channel
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest) BatchInputString(batchInputString BatchInputString) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest {
	r.batchInputString = &batchInputString
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest) BusinessUnitId(businessUnitId int64) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest {
	r.businessUnitId = &businessUnitId
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest) Execute() (*BatchResponsePublicWideStatusBulkResponse, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRead Batch retrieve contacts who have opted out of all communications

Checks whether a set of contacts have opted out of all communications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRead(ctx context.Context) ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest {
	return ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicWideStatusBulkResponse
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadExecute(r ApiPostCommunicationPreferencesV4StatusesBatchUnsubscribeAllReadRequest) (*BatchResponsePublicWideStatusBulkResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicWideStatusBulkResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesBatchUnsubscribeAllRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/batch/unsubscribe-all/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	batchInputPublicStatusRequest *BatchInputPublicStatusRequest
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest) BatchInputPublicStatusRequest(batchInputPublicStatusRequest BatchInputPublicStatusRequest) ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest {
	r.batchInputPublicStatusRequest = &batchInputPublicStatusRequest
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest) Execute() (*BatchResponsePublicStatus, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesBatchWriteExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesBatchWrite Batch update subscription status

Update the subscription status for a set of contacts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchWrite(ctx context.Context) ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest {
	return ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicStatus
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesBatchWriteExecute(r ApiPostCommunicationPreferencesV4StatusesBatchWriteRequest) (*BatchResponsePublicStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesBatchWrite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/batch/write"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPublicStatusRequest == nil {
		return localVarReturnValue, nil, reportError("batchInputPublicStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPublicStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	subscriberIdString string
	partialPublicStatusRequest *PartialPublicStatusRequest
}

func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest) PartialPublicStatusRequest(partialPublicStatusRequest PartialPublicStatusRequest) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest {
	r.partialPublicStatusRequest = &partialPublicStatusRequest
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest) Execute() (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesSubscriberIdStringExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesSubscriberIdString Update a contact's subscription status

Set the subscription status of a specific contact.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriberIdString The contact's email address.
 @return ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesSubscriberIdString(ctx context.Context, subscriberIdString string) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest {
	return ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest{
		ApiService: a,
		ctx: ctx,
		subscriberIdString: subscriberIdString,
	}
}

// Execute executes the request
//  @return ActionResponseWithResultsPublicStatus
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesSubscriberIdStringExecute(r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringRequest) (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionResponseWithResultsPublicStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesSubscriberIdString")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/{subscriberIdString}"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriberIdString"+"}", url.PathEscape(parameterValueToString(r.subscriberIdString, "subscriberIdString")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.partialPublicStatusRequest == nil {
		return localVarReturnValue, nil, reportError("partialPublicStatusRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.partialPublicStatusRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest struct {
	ctx context.Context
	ApiService *SubscriptionStatusAPIService
	subscriberIdString string
	channel *string
	businessUnitId *int64
	verbose *bool
}

// The channel type for the subscription type. Currently, the only supported channel type is &#x60;EMAIL&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Channel(channel string) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.channel = &channel
	return r
}

// If you have the [business unit add-on](https://developers.hubspot.com/beta-docs/guides/api/settings/business-units-api), include this parameter to filter results by business unit ID. The default Account business unit will always use &#x60;0&#x60;.
func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) BusinessUnitId(businessUnitId int64) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.businessUnitId = &businessUnitId
	return r
}

// Set to &#x60;true&#x60; to include the details of the updated subscription statuses in the response. Not including this parameter will result in an empty response.
func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Verbose(verbose bool) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	r.verbose = &verbose
	return r
}

func (r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) Execute() (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	return r.ApiService.PostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllExecute(r)
}

/*
PostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll Unsubscribe a contact from all subscriptions

Unsubscribe a contact from all email subscriptions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param subscriberIdString The contact's email address.
 @return ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest
*/
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll(ctx context.Context, subscriberIdString string) ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest {
	return ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest{
		ApiService: a,
		ctx: ctx,
		subscriberIdString: subscriberIdString,
	}
}

// Execute executes the request
//  @return ActionResponseWithResultsPublicStatus
func (a *SubscriptionStatusAPIService) PostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllExecute(r ApiPostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAllRequest) (*ActionResponseWithResultsPublicStatus, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionResponseWithResultsPublicStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionStatusAPIService.PostCommunicationPreferencesV4StatusesSubscriberIdStringUnsubscribeAll")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/communication-preferences/v4/statuses/{subscriberIdString}/unsubscribe-all"
	localVarPath = strings.Replace(localVarPath, "{"+"subscriberIdString"+"}", url.PathEscape(parameterValueToString(r.subscriberIdString, "subscriberIdString")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.channel == nil {
		return localVarReturnValue, nil, reportError("channel is required and must be specified")
	}

	if r.businessUnitId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "businessUnitId", r.businessUnitId, "form", "")
	}
	if r.verbose != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "verbose", r.verbose, "form", "")
	} else {
		var defaultValue bool = false
		r.verbose = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "channel", r.channel, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
