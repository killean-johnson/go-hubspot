/*
CMS Media Bridge

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package media_bridge

import (
	"encoding/json"
	"fmt"
	"gopkg.in/validator.v2"
)

// OrInputsInner - struct for OrInputsInner
type OrInputsInner struct {
	AddNumbers *AddNumbers
	And *And
	BeginsWith *BeginsWith
	BooleanPropertyVariable *BooleanPropertyVariable
	ConcatStrings *ConcatStrings
	ConstantBoolean *ConstantBoolean
	ConstantNumber *ConstantNumber
	ConstantString *ConstantString
	Contains *Contains
	Date *Date
	DatedExchangeRate *DatedExchangeRate
	DivideNumbers *DivideNumbers
	ExtractMostRecentEmailReplyHtml *ExtractMostRecentEmailReplyHtml
	ExtractMostRecentEmailReplyText *ExtractMostRecentEmailReplyText
	ExtractMostRecentPlainTextEmailReply *ExtractMostRecentPlainTextEmailReply
	FetchCurrencyDecimalPlaces *FetchCurrencyDecimalPlaces
	FetchExchangeRate *FetchExchangeRate
	FetchSingleCurrencyPortalCurrency *FetchSingleCurrencyPortalCurrency
	FormatFullName *FormatFullName
	HasEmailReply *HasEmailReply
	HasPlainTextEmailReply *HasPlainTextEmailReply
	IfBoolean *IfBoolean
	IfNumber *IfNumber
	IfString *IfString
	IsEngagementType *IsEngagementType
	IsPresent *IsPresent
	LessThan *LessThan
	LessThanOrEqual *LessThanOrEqual
	LowerCase *LowerCase
	MaxNumbers *MaxNumbers
	MinNumbers *MinNumbers
	Month *Month
	MoreThan *MoreThan
	MoreThanOrEqual *MoreThanOrEqual
	MultiplyNumbers *MultiplyNumbers
	Not *Not
	Now *Now
	NumberEquals *NumberEquals
	NumberPropertyVariable *NumberPropertyVariable
	NumberToString *NumberToString
	Or *Or
	ParseNumber *ParseNumber
	PeriodToMonths *PeriodToMonths
	PipelineProbability *PipelineProbability
	RoundDownNumbers *RoundDownNumbers
	RoundNearestNumbers *RoundNearestNumbers
	RoundUpNumbers *RoundUpNumbers
	SetContainsString *SetContainsString
	StringEquals *StringEquals
	StringPropertyVariable *StringPropertyVariable
	SubtractNumbers *SubtractNumbers
	TimeBetween *TimeBetween
	TimestampOfPropertyVariable *TimestampOfPropertyVariable
	UpperCase *UpperCase
	Xor *Xor
	Year *Year
}

// AddNumbersAsOrInputsInner is a convenience function that returns AddNumbers wrapped in OrInputsInner
func AddNumbersAsOrInputsInner(v *AddNumbers) OrInputsInner {
	return OrInputsInner{
		AddNumbers: v,
	}
}

// AndAsOrInputsInner is a convenience function that returns And wrapped in OrInputsInner
func AndAsOrInputsInner(v *And) OrInputsInner {
	return OrInputsInner{
		And: v,
	}
}

// BeginsWithAsOrInputsInner is a convenience function that returns BeginsWith wrapped in OrInputsInner
func BeginsWithAsOrInputsInner(v *BeginsWith) OrInputsInner {
	return OrInputsInner{
		BeginsWith: v,
	}
}

// BooleanPropertyVariableAsOrInputsInner is a convenience function that returns BooleanPropertyVariable wrapped in OrInputsInner
func BooleanPropertyVariableAsOrInputsInner(v *BooleanPropertyVariable) OrInputsInner {
	return OrInputsInner{
		BooleanPropertyVariable: v,
	}
}

// ConcatStringsAsOrInputsInner is a convenience function that returns ConcatStrings wrapped in OrInputsInner
func ConcatStringsAsOrInputsInner(v *ConcatStrings) OrInputsInner {
	return OrInputsInner{
		ConcatStrings: v,
	}
}

// ConstantBooleanAsOrInputsInner is a convenience function that returns ConstantBoolean wrapped in OrInputsInner
func ConstantBooleanAsOrInputsInner(v *ConstantBoolean) OrInputsInner {
	return OrInputsInner{
		ConstantBoolean: v,
	}
}

// ConstantNumberAsOrInputsInner is a convenience function that returns ConstantNumber wrapped in OrInputsInner
func ConstantNumberAsOrInputsInner(v *ConstantNumber) OrInputsInner {
	return OrInputsInner{
		ConstantNumber: v,
	}
}

// ConstantStringAsOrInputsInner is a convenience function that returns ConstantString wrapped in OrInputsInner
func ConstantStringAsOrInputsInner(v *ConstantString) OrInputsInner {
	return OrInputsInner{
		ConstantString: v,
	}
}

// ContainsAsOrInputsInner is a convenience function that returns Contains wrapped in OrInputsInner
func ContainsAsOrInputsInner(v *Contains) OrInputsInner {
	return OrInputsInner{
		Contains: v,
	}
}

// DateAsOrInputsInner is a convenience function that returns Date wrapped in OrInputsInner
func DateAsOrInputsInner(v *Date) OrInputsInner {
	return OrInputsInner{
		Date: v,
	}
}

// DatedExchangeRateAsOrInputsInner is a convenience function that returns DatedExchangeRate wrapped in OrInputsInner
func DatedExchangeRateAsOrInputsInner(v *DatedExchangeRate) OrInputsInner {
	return OrInputsInner{
		DatedExchangeRate: v,
	}
}

// DivideNumbersAsOrInputsInner is a convenience function that returns DivideNumbers wrapped in OrInputsInner
func DivideNumbersAsOrInputsInner(v *DivideNumbers) OrInputsInner {
	return OrInputsInner{
		DivideNumbers: v,
	}
}

// ExtractMostRecentEmailReplyHtmlAsOrInputsInner is a convenience function that returns ExtractMostRecentEmailReplyHtml wrapped in OrInputsInner
func ExtractMostRecentEmailReplyHtmlAsOrInputsInner(v *ExtractMostRecentEmailReplyHtml) OrInputsInner {
	return OrInputsInner{
		ExtractMostRecentEmailReplyHtml: v,
	}
}

// ExtractMostRecentEmailReplyTextAsOrInputsInner is a convenience function that returns ExtractMostRecentEmailReplyText wrapped in OrInputsInner
func ExtractMostRecentEmailReplyTextAsOrInputsInner(v *ExtractMostRecentEmailReplyText) OrInputsInner {
	return OrInputsInner{
		ExtractMostRecentEmailReplyText: v,
	}
}

// ExtractMostRecentPlainTextEmailReplyAsOrInputsInner is a convenience function that returns ExtractMostRecentPlainTextEmailReply wrapped in OrInputsInner
func ExtractMostRecentPlainTextEmailReplyAsOrInputsInner(v *ExtractMostRecentPlainTextEmailReply) OrInputsInner {
	return OrInputsInner{
		ExtractMostRecentPlainTextEmailReply: v,
	}
}

// FetchCurrencyDecimalPlacesAsOrInputsInner is a convenience function that returns FetchCurrencyDecimalPlaces wrapped in OrInputsInner
func FetchCurrencyDecimalPlacesAsOrInputsInner(v *FetchCurrencyDecimalPlaces) OrInputsInner {
	return OrInputsInner{
		FetchCurrencyDecimalPlaces: v,
	}
}

// FetchExchangeRateAsOrInputsInner is a convenience function that returns FetchExchangeRate wrapped in OrInputsInner
func FetchExchangeRateAsOrInputsInner(v *FetchExchangeRate) OrInputsInner {
	return OrInputsInner{
		FetchExchangeRate: v,
	}
}

// FetchSingleCurrencyPortalCurrencyAsOrInputsInner is a convenience function that returns FetchSingleCurrencyPortalCurrency wrapped in OrInputsInner
func FetchSingleCurrencyPortalCurrencyAsOrInputsInner(v *FetchSingleCurrencyPortalCurrency) OrInputsInner {
	return OrInputsInner{
		FetchSingleCurrencyPortalCurrency: v,
	}
}

// FormatFullNameAsOrInputsInner is a convenience function that returns FormatFullName wrapped in OrInputsInner
func FormatFullNameAsOrInputsInner(v *FormatFullName) OrInputsInner {
	return OrInputsInner{
		FormatFullName: v,
	}
}

// HasEmailReplyAsOrInputsInner is a convenience function that returns HasEmailReply wrapped in OrInputsInner
func HasEmailReplyAsOrInputsInner(v *HasEmailReply) OrInputsInner {
	return OrInputsInner{
		HasEmailReply: v,
	}
}

// HasPlainTextEmailReplyAsOrInputsInner is a convenience function that returns HasPlainTextEmailReply wrapped in OrInputsInner
func HasPlainTextEmailReplyAsOrInputsInner(v *HasPlainTextEmailReply) OrInputsInner {
	return OrInputsInner{
		HasPlainTextEmailReply: v,
	}
}

// IfBooleanAsOrInputsInner is a convenience function that returns IfBoolean wrapped in OrInputsInner
func IfBooleanAsOrInputsInner(v *IfBoolean) OrInputsInner {
	return OrInputsInner{
		IfBoolean: v,
	}
}

// IfNumberAsOrInputsInner is a convenience function that returns IfNumber wrapped in OrInputsInner
func IfNumberAsOrInputsInner(v *IfNumber) OrInputsInner {
	return OrInputsInner{
		IfNumber: v,
	}
}

// IfStringAsOrInputsInner is a convenience function that returns IfString wrapped in OrInputsInner
func IfStringAsOrInputsInner(v *IfString) OrInputsInner {
	return OrInputsInner{
		IfString: v,
	}
}

// IsEngagementTypeAsOrInputsInner is a convenience function that returns IsEngagementType wrapped in OrInputsInner
func IsEngagementTypeAsOrInputsInner(v *IsEngagementType) OrInputsInner {
	return OrInputsInner{
		IsEngagementType: v,
	}
}

// IsPresentAsOrInputsInner is a convenience function that returns IsPresent wrapped in OrInputsInner
func IsPresentAsOrInputsInner(v *IsPresent) OrInputsInner {
	return OrInputsInner{
		IsPresent: v,
	}
}

// LessThanAsOrInputsInner is a convenience function that returns LessThan wrapped in OrInputsInner
func LessThanAsOrInputsInner(v *LessThan) OrInputsInner {
	return OrInputsInner{
		LessThan: v,
	}
}

// LessThanOrEqualAsOrInputsInner is a convenience function that returns LessThanOrEqual wrapped in OrInputsInner
func LessThanOrEqualAsOrInputsInner(v *LessThanOrEqual) OrInputsInner {
	return OrInputsInner{
		LessThanOrEqual: v,
	}
}

// LowerCaseAsOrInputsInner is a convenience function that returns LowerCase wrapped in OrInputsInner
func LowerCaseAsOrInputsInner(v *LowerCase) OrInputsInner {
	return OrInputsInner{
		LowerCase: v,
	}
}

// MaxNumbersAsOrInputsInner is a convenience function that returns MaxNumbers wrapped in OrInputsInner
func MaxNumbersAsOrInputsInner(v *MaxNumbers) OrInputsInner {
	return OrInputsInner{
		MaxNumbers: v,
	}
}

// MinNumbersAsOrInputsInner is a convenience function that returns MinNumbers wrapped in OrInputsInner
func MinNumbersAsOrInputsInner(v *MinNumbers) OrInputsInner {
	return OrInputsInner{
		MinNumbers: v,
	}
}

// MonthAsOrInputsInner is a convenience function that returns Month wrapped in OrInputsInner
func MonthAsOrInputsInner(v *Month) OrInputsInner {
	return OrInputsInner{
		Month: v,
	}
}

// MoreThanAsOrInputsInner is a convenience function that returns MoreThan wrapped in OrInputsInner
func MoreThanAsOrInputsInner(v *MoreThan) OrInputsInner {
	return OrInputsInner{
		MoreThan: v,
	}
}

// MoreThanOrEqualAsOrInputsInner is a convenience function that returns MoreThanOrEqual wrapped in OrInputsInner
func MoreThanOrEqualAsOrInputsInner(v *MoreThanOrEqual) OrInputsInner {
	return OrInputsInner{
		MoreThanOrEqual: v,
	}
}

// MultiplyNumbersAsOrInputsInner is a convenience function that returns MultiplyNumbers wrapped in OrInputsInner
func MultiplyNumbersAsOrInputsInner(v *MultiplyNumbers) OrInputsInner {
	return OrInputsInner{
		MultiplyNumbers: v,
	}
}

// NotAsOrInputsInner is a convenience function that returns Not wrapped in OrInputsInner
func NotAsOrInputsInner(v *Not) OrInputsInner {
	return OrInputsInner{
		Not: v,
	}
}

// NowAsOrInputsInner is a convenience function that returns Now wrapped in OrInputsInner
func NowAsOrInputsInner(v *Now) OrInputsInner {
	return OrInputsInner{
		Now: v,
	}
}

// NumberEqualsAsOrInputsInner is a convenience function that returns NumberEquals wrapped in OrInputsInner
func NumberEqualsAsOrInputsInner(v *NumberEquals) OrInputsInner {
	return OrInputsInner{
		NumberEquals: v,
	}
}

// NumberPropertyVariableAsOrInputsInner is a convenience function that returns NumberPropertyVariable wrapped in OrInputsInner
func NumberPropertyVariableAsOrInputsInner(v *NumberPropertyVariable) OrInputsInner {
	return OrInputsInner{
		NumberPropertyVariable: v,
	}
}

// NumberToStringAsOrInputsInner is a convenience function that returns NumberToString wrapped in OrInputsInner
func NumberToStringAsOrInputsInner(v *NumberToString) OrInputsInner {
	return OrInputsInner{
		NumberToString: v,
	}
}

// OrAsOrInputsInner is a convenience function that returns Or wrapped in OrInputsInner
func OrAsOrInputsInner(v *Or) OrInputsInner {
	return OrInputsInner{
		Or: v,
	}
}

// ParseNumberAsOrInputsInner is a convenience function that returns ParseNumber wrapped in OrInputsInner
func ParseNumberAsOrInputsInner(v *ParseNumber) OrInputsInner {
	return OrInputsInner{
		ParseNumber: v,
	}
}

// PeriodToMonthsAsOrInputsInner is a convenience function that returns PeriodToMonths wrapped in OrInputsInner
func PeriodToMonthsAsOrInputsInner(v *PeriodToMonths) OrInputsInner {
	return OrInputsInner{
		PeriodToMonths: v,
	}
}

// PipelineProbabilityAsOrInputsInner is a convenience function that returns PipelineProbability wrapped in OrInputsInner
func PipelineProbabilityAsOrInputsInner(v *PipelineProbability) OrInputsInner {
	return OrInputsInner{
		PipelineProbability: v,
	}
}

// RoundDownNumbersAsOrInputsInner is a convenience function that returns RoundDownNumbers wrapped in OrInputsInner
func RoundDownNumbersAsOrInputsInner(v *RoundDownNumbers) OrInputsInner {
	return OrInputsInner{
		RoundDownNumbers: v,
	}
}

// RoundNearestNumbersAsOrInputsInner is a convenience function that returns RoundNearestNumbers wrapped in OrInputsInner
func RoundNearestNumbersAsOrInputsInner(v *RoundNearestNumbers) OrInputsInner {
	return OrInputsInner{
		RoundNearestNumbers: v,
	}
}

// RoundUpNumbersAsOrInputsInner is a convenience function that returns RoundUpNumbers wrapped in OrInputsInner
func RoundUpNumbersAsOrInputsInner(v *RoundUpNumbers) OrInputsInner {
	return OrInputsInner{
		RoundUpNumbers: v,
	}
}

// SetContainsStringAsOrInputsInner is a convenience function that returns SetContainsString wrapped in OrInputsInner
func SetContainsStringAsOrInputsInner(v *SetContainsString) OrInputsInner {
	return OrInputsInner{
		SetContainsString: v,
	}
}

// StringEqualsAsOrInputsInner is a convenience function that returns StringEquals wrapped in OrInputsInner
func StringEqualsAsOrInputsInner(v *StringEquals) OrInputsInner {
	return OrInputsInner{
		StringEquals: v,
	}
}

// StringPropertyVariableAsOrInputsInner is a convenience function that returns StringPropertyVariable wrapped in OrInputsInner
func StringPropertyVariableAsOrInputsInner(v *StringPropertyVariable) OrInputsInner {
	return OrInputsInner{
		StringPropertyVariable: v,
	}
}

// SubtractNumbersAsOrInputsInner is a convenience function that returns SubtractNumbers wrapped in OrInputsInner
func SubtractNumbersAsOrInputsInner(v *SubtractNumbers) OrInputsInner {
	return OrInputsInner{
		SubtractNumbers: v,
	}
}

// TimeBetweenAsOrInputsInner is a convenience function that returns TimeBetween wrapped in OrInputsInner
func TimeBetweenAsOrInputsInner(v *TimeBetween) OrInputsInner {
	return OrInputsInner{
		TimeBetween: v,
	}
}

// TimestampOfPropertyVariableAsOrInputsInner is a convenience function that returns TimestampOfPropertyVariable wrapped in OrInputsInner
func TimestampOfPropertyVariableAsOrInputsInner(v *TimestampOfPropertyVariable) OrInputsInner {
	return OrInputsInner{
		TimestampOfPropertyVariable: v,
	}
}

// UpperCaseAsOrInputsInner is a convenience function that returns UpperCase wrapped in OrInputsInner
func UpperCaseAsOrInputsInner(v *UpperCase) OrInputsInner {
	return OrInputsInner{
		UpperCase: v,
	}
}

// XorAsOrInputsInner is a convenience function that returns Xor wrapped in OrInputsInner
func XorAsOrInputsInner(v *Xor) OrInputsInner {
	return OrInputsInner{
		Xor: v,
	}
}

// YearAsOrInputsInner is a convenience function that returns Year wrapped in OrInputsInner
func YearAsOrInputsInner(v *Year) OrInputsInner {
	return OrInputsInner{
		Year: v,
	}
}


// Unmarshal JSON data into one of the pointers in the struct
func (dst *OrInputsInner) UnmarshalJSON(data []byte) error {
	var err error
	match := 0
	// try to unmarshal data into AddNumbers
	err = newStrictDecoder(data).Decode(&dst.AddNumbers)
	if err == nil {
		jsonAddNumbers, _ := json.Marshal(dst.AddNumbers)
		if string(jsonAddNumbers) == "{}" { // empty struct
			dst.AddNumbers = nil
		} else {
			if err = validator.Validate(dst.AddNumbers); err != nil {
				dst.AddNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.AddNumbers = nil
	}

	// try to unmarshal data into And
	err = newStrictDecoder(data).Decode(&dst.And)
	if err == nil {
		jsonAnd, _ := json.Marshal(dst.And)
		if string(jsonAnd) == "{}" { // empty struct
			dst.And = nil
		} else {
			if err = validator.Validate(dst.And); err != nil {
				dst.And = nil
			} else {
				match++
			}
		}
	} else {
		dst.And = nil
	}

	// try to unmarshal data into BeginsWith
	err = newStrictDecoder(data).Decode(&dst.BeginsWith)
	if err == nil {
		jsonBeginsWith, _ := json.Marshal(dst.BeginsWith)
		if string(jsonBeginsWith) == "{}" { // empty struct
			dst.BeginsWith = nil
		} else {
			if err = validator.Validate(dst.BeginsWith); err != nil {
				dst.BeginsWith = nil
			} else {
				match++
			}
		}
	} else {
		dst.BeginsWith = nil
	}

	// try to unmarshal data into BooleanPropertyVariable
	err = newStrictDecoder(data).Decode(&dst.BooleanPropertyVariable)
	if err == nil {
		jsonBooleanPropertyVariable, _ := json.Marshal(dst.BooleanPropertyVariable)
		if string(jsonBooleanPropertyVariable) == "{}" { // empty struct
			dst.BooleanPropertyVariable = nil
		} else {
			if err = validator.Validate(dst.BooleanPropertyVariable); err != nil {
				dst.BooleanPropertyVariable = nil
			} else {
				match++
			}
		}
	} else {
		dst.BooleanPropertyVariable = nil
	}

	// try to unmarshal data into ConcatStrings
	err = newStrictDecoder(data).Decode(&dst.ConcatStrings)
	if err == nil {
		jsonConcatStrings, _ := json.Marshal(dst.ConcatStrings)
		if string(jsonConcatStrings) == "{}" { // empty struct
			dst.ConcatStrings = nil
		} else {
			if err = validator.Validate(dst.ConcatStrings); err != nil {
				dst.ConcatStrings = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConcatStrings = nil
	}

	// try to unmarshal data into ConstantBoolean
	err = newStrictDecoder(data).Decode(&dst.ConstantBoolean)
	if err == nil {
		jsonConstantBoolean, _ := json.Marshal(dst.ConstantBoolean)
		if string(jsonConstantBoolean) == "{}" { // empty struct
			dst.ConstantBoolean = nil
		} else {
			if err = validator.Validate(dst.ConstantBoolean); err != nil {
				dst.ConstantBoolean = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConstantBoolean = nil
	}

	// try to unmarshal data into ConstantNumber
	err = newStrictDecoder(data).Decode(&dst.ConstantNumber)
	if err == nil {
		jsonConstantNumber, _ := json.Marshal(dst.ConstantNumber)
		if string(jsonConstantNumber) == "{}" { // empty struct
			dst.ConstantNumber = nil
		} else {
			if err = validator.Validate(dst.ConstantNumber); err != nil {
				dst.ConstantNumber = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConstantNumber = nil
	}

	// try to unmarshal data into ConstantString
	err = newStrictDecoder(data).Decode(&dst.ConstantString)
	if err == nil {
		jsonConstantString, _ := json.Marshal(dst.ConstantString)
		if string(jsonConstantString) == "{}" { // empty struct
			dst.ConstantString = nil
		} else {
			if err = validator.Validate(dst.ConstantString); err != nil {
				dst.ConstantString = nil
			} else {
				match++
			}
		}
	} else {
		dst.ConstantString = nil
	}

	// try to unmarshal data into Contains
	err = newStrictDecoder(data).Decode(&dst.Contains)
	if err == nil {
		jsonContains, _ := json.Marshal(dst.Contains)
		if string(jsonContains) == "{}" { // empty struct
			dst.Contains = nil
		} else {
			if err = validator.Validate(dst.Contains); err != nil {
				dst.Contains = nil
			} else {
				match++
			}
		}
	} else {
		dst.Contains = nil
	}

	// try to unmarshal data into Date
	err = newStrictDecoder(data).Decode(&dst.Date)
	if err == nil {
		jsonDate, _ := json.Marshal(dst.Date)
		if string(jsonDate) == "{}" { // empty struct
			dst.Date = nil
		} else {
			if err = validator.Validate(dst.Date); err != nil {
				dst.Date = nil
			} else {
				match++
			}
		}
	} else {
		dst.Date = nil
	}

	// try to unmarshal data into DatedExchangeRate
	err = newStrictDecoder(data).Decode(&dst.DatedExchangeRate)
	if err == nil {
		jsonDatedExchangeRate, _ := json.Marshal(dst.DatedExchangeRate)
		if string(jsonDatedExchangeRate) == "{}" { // empty struct
			dst.DatedExchangeRate = nil
		} else {
			if err = validator.Validate(dst.DatedExchangeRate); err != nil {
				dst.DatedExchangeRate = nil
			} else {
				match++
			}
		}
	} else {
		dst.DatedExchangeRate = nil
	}

	// try to unmarshal data into DivideNumbers
	err = newStrictDecoder(data).Decode(&dst.DivideNumbers)
	if err == nil {
		jsonDivideNumbers, _ := json.Marshal(dst.DivideNumbers)
		if string(jsonDivideNumbers) == "{}" { // empty struct
			dst.DivideNumbers = nil
		} else {
			if err = validator.Validate(dst.DivideNumbers); err != nil {
				dst.DivideNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.DivideNumbers = nil
	}

	// try to unmarshal data into ExtractMostRecentEmailReplyHtml
	err = newStrictDecoder(data).Decode(&dst.ExtractMostRecentEmailReplyHtml)
	if err == nil {
		jsonExtractMostRecentEmailReplyHtml, _ := json.Marshal(dst.ExtractMostRecentEmailReplyHtml)
		if string(jsonExtractMostRecentEmailReplyHtml) == "{}" { // empty struct
			dst.ExtractMostRecentEmailReplyHtml = nil
		} else {
			if err = validator.Validate(dst.ExtractMostRecentEmailReplyHtml); err != nil {
				dst.ExtractMostRecentEmailReplyHtml = nil
			} else {
				match++
			}
		}
	} else {
		dst.ExtractMostRecentEmailReplyHtml = nil
	}

	// try to unmarshal data into ExtractMostRecentEmailReplyText
	err = newStrictDecoder(data).Decode(&dst.ExtractMostRecentEmailReplyText)
	if err == nil {
		jsonExtractMostRecentEmailReplyText, _ := json.Marshal(dst.ExtractMostRecentEmailReplyText)
		if string(jsonExtractMostRecentEmailReplyText) == "{}" { // empty struct
			dst.ExtractMostRecentEmailReplyText = nil
		} else {
			if err = validator.Validate(dst.ExtractMostRecentEmailReplyText); err != nil {
				dst.ExtractMostRecentEmailReplyText = nil
			} else {
				match++
			}
		}
	} else {
		dst.ExtractMostRecentEmailReplyText = nil
	}

	// try to unmarshal data into ExtractMostRecentPlainTextEmailReply
	err = newStrictDecoder(data).Decode(&dst.ExtractMostRecentPlainTextEmailReply)
	if err == nil {
		jsonExtractMostRecentPlainTextEmailReply, _ := json.Marshal(dst.ExtractMostRecentPlainTextEmailReply)
		if string(jsonExtractMostRecentPlainTextEmailReply) == "{}" { // empty struct
			dst.ExtractMostRecentPlainTextEmailReply = nil
		} else {
			if err = validator.Validate(dst.ExtractMostRecentPlainTextEmailReply); err != nil {
				dst.ExtractMostRecentPlainTextEmailReply = nil
			} else {
				match++
			}
		}
	} else {
		dst.ExtractMostRecentPlainTextEmailReply = nil
	}

	// try to unmarshal data into FetchCurrencyDecimalPlaces
	err = newStrictDecoder(data).Decode(&dst.FetchCurrencyDecimalPlaces)
	if err == nil {
		jsonFetchCurrencyDecimalPlaces, _ := json.Marshal(dst.FetchCurrencyDecimalPlaces)
		if string(jsonFetchCurrencyDecimalPlaces) == "{}" { // empty struct
			dst.FetchCurrencyDecimalPlaces = nil
		} else {
			if err = validator.Validate(dst.FetchCurrencyDecimalPlaces); err != nil {
				dst.FetchCurrencyDecimalPlaces = nil
			} else {
				match++
			}
		}
	} else {
		dst.FetchCurrencyDecimalPlaces = nil
	}

	// try to unmarshal data into FetchExchangeRate
	err = newStrictDecoder(data).Decode(&dst.FetchExchangeRate)
	if err == nil {
		jsonFetchExchangeRate, _ := json.Marshal(dst.FetchExchangeRate)
		if string(jsonFetchExchangeRate) == "{}" { // empty struct
			dst.FetchExchangeRate = nil
		} else {
			if err = validator.Validate(dst.FetchExchangeRate); err != nil {
				dst.FetchExchangeRate = nil
			} else {
				match++
			}
		}
	} else {
		dst.FetchExchangeRate = nil
	}

	// try to unmarshal data into FetchSingleCurrencyPortalCurrency
	err = newStrictDecoder(data).Decode(&dst.FetchSingleCurrencyPortalCurrency)
	if err == nil {
		jsonFetchSingleCurrencyPortalCurrency, _ := json.Marshal(dst.FetchSingleCurrencyPortalCurrency)
		if string(jsonFetchSingleCurrencyPortalCurrency) == "{}" { // empty struct
			dst.FetchSingleCurrencyPortalCurrency = nil
		} else {
			if err = validator.Validate(dst.FetchSingleCurrencyPortalCurrency); err != nil {
				dst.FetchSingleCurrencyPortalCurrency = nil
			} else {
				match++
			}
		}
	} else {
		dst.FetchSingleCurrencyPortalCurrency = nil
	}

	// try to unmarshal data into FormatFullName
	err = newStrictDecoder(data).Decode(&dst.FormatFullName)
	if err == nil {
		jsonFormatFullName, _ := json.Marshal(dst.FormatFullName)
		if string(jsonFormatFullName) == "{}" { // empty struct
			dst.FormatFullName = nil
		} else {
			if err = validator.Validate(dst.FormatFullName); err != nil {
				dst.FormatFullName = nil
			} else {
				match++
			}
		}
	} else {
		dst.FormatFullName = nil
	}

	// try to unmarshal data into HasEmailReply
	err = newStrictDecoder(data).Decode(&dst.HasEmailReply)
	if err == nil {
		jsonHasEmailReply, _ := json.Marshal(dst.HasEmailReply)
		if string(jsonHasEmailReply) == "{}" { // empty struct
			dst.HasEmailReply = nil
		} else {
			if err = validator.Validate(dst.HasEmailReply); err != nil {
				dst.HasEmailReply = nil
			} else {
				match++
			}
		}
	} else {
		dst.HasEmailReply = nil
	}

	// try to unmarshal data into HasPlainTextEmailReply
	err = newStrictDecoder(data).Decode(&dst.HasPlainTextEmailReply)
	if err == nil {
		jsonHasPlainTextEmailReply, _ := json.Marshal(dst.HasPlainTextEmailReply)
		if string(jsonHasPlainTextEmailReply) == "{}" { // empty struct
			dst.HasPlainTextEmailReply = nil
		} else {
			if err = validator.Validate(dst.HasPlainTextEmailReply); err != nil {
				dst.HasPlainTextEmailReply = nil
			} else {
				match++
			}
		}
	} else {
		dst.HasPlainTextEmailReply = nil
	}

	// try to unmarshal data into IfBoolean
	err = newStrictDecoder(data).Decode(&dst.IfBoolean)
	if err == nil {
		jsonIfBoolean, _ := json.Marshal(dst.IfBoolean)
		if string(jsonIfBoolean) == "{}" { // empty struct
			dst.IfBoolean = nil
		} else {
			if err = validator.Validate(dst.IfBoolean); err != nil {
				dst.IfBoolean = nil
			} else {
				match++
			}
		}
	} else {
		dst.IfBoolean = nil
	}

	// try to unmarshal data into IfNumber
	err = newStrictDecoder(data).Decode(&dst.IfNumber)
	if err == nil {
		jsonIfNumber, _ := json.Marshal(dst.IfNumber)
		if string(jsonIfNumber) == "{}" { // empty struct
			dst.IfNumber = nil
		} else {
			if err = validator.Validate(dst.IfNumber); err != nil {
				dst.IfNumber = nil
			} else {
				match++
			}
		}
	} else {
		dst.IfNumber = nil
	}

	// try to unmarshal data into IfString
	err = newStrictDecoder(data).Decode(&dst.IfString)
	if err == nil {
		jsonIfString, _ := json.Marshal(dst.IfString)
		if string(jsonIfString) == "{}" { // empty struct
			dst.IfString = nil
		} else {
			if err = validator.Validate(dst.IfString); err != nil {
				dst.IfString = nil
			} else {
				match++
			}
		}
	} else {
		dst.IfString = nil
	}

	// try to unmarshal data into IsEngagementType
	err = newStrictDecoder(data).Decode(&dst.IsEngagementType)
	if err == nil {
		jsonIsEngagementType, _ := json.Marshal(dst.IsEngagementType)
		if string(jsonIsEngagementType) == "{}" { // empty struct
			dst.IsEngagementType = nil
		} else {
			if err = validator.Validate(dst.IsEngagementType); err != nil {
				dst.IsEngagementType = nil
			} else {
				match++
			}
		}
	} else {
		dst.IsEngagementType = nil
	}

	// try to unmarshal data into IsPresent
	err = newStrictDecoder(data).Decode(&dst.IsPresent)
	if err == nil {
		jsonIsPresent, _ := json.Marshal(dst.IsPresent)
		if string(jsonIsPresent) == "{}" { // empty struct
			dst.IsPresent = nil
		} else {
			if err = validator.Validate(dst.IsPresent); err != nil {
				dst.IsPresent = nil
			} else {
				match++
			}
		}
	} else {
		dst.IsPresent = nil
	}

	// try to unmarshal data into LessThan
	err = newStrictDecoder(data).Decode(&dst.LessThan)
	if err == nil {
		jsonLessThan, _ := json.Marshal(dst.LessThan)
		if string(jsonLessThan) == "{}" { // empty struct
			dst.LessThan = nil
		} else {
			if err = validator.Validate(dst.LessThan); err != nil {
				dst.LessThan = nil
			} else {
				match++
			}
		}
	} else {
		dst.LessThan = nil
	}

	// try to unmarshal data into LessThanOrEqual
	err = newStrictDecoder(data).Decode(&dst.LessThanOrEqual)
	if err == nil {
		jsonLessThanOrEqual, _ := json.Marshal(dst.LessThanOrEqual)
		if string(jsonLessThanOrEqual) == "{}" { // empty struct
			dst.LessThanOrEqual = nil
		} else {
			if err = validator.Validate(dst.LessThanOrEqual); err != nil {
				dst.LessThanOrEqual = nil
			} else {
				match++
			}
		}
	} else {
		dst.LessThanOrEqual = nil
	}

	// try to unmarshal data into LowerCase
	err = newStrictDecoder(data).Decode(&dst.LowerCase)
	if err == nil {
		jsonLowerCase, _ := json.Marshal(dst.LowerCase)
		if string(jsonLowerCase) == "{}" { // empty struct
			dst.LowerCase = nil
		} else {
			if err = validator.Validate(dst.LowerCase); err != nil {
				dst.LowerCase = nil
			} else {
				match++
			}
		}
	} else {
		dst.LowerCase = nil
	}

	// try to unmarshal data into MaxNumbers
	err = newStrictDecoder(data).Decode(&dst.MaxNumbers)
	if err == nil {
		jsonMaxNumbers, _ := json.Marshal(dst.MaxNumbers)
		if string(jsonMaxNumbers) == "{}" { // empty struct
			dst.MaxNumbers = nil
		} else {
			if err = validator.Validate(dst.MaxNumbers); err != nil {
				dst.MaxNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.MaxNumbers = nil
	}

	// try to unmarshal data into MinNumbers
	err = newStrictDecoder(data).Decode(&dst.MinNumbers)
	if err == nil {
		jsonMinNumbers, _ := json.Marshal(dst.MinNumbers)
		if string(jsonMinNumbers) == "{}" { // empty struct
			dst.MinNumbers = nil
		} else {
			if err = validator.Validate(dst.MinNumbers); err != nil {
				dst.MinNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.MinNumbers = nil
	}

	// try to unmarshal data into Month
	err = newStrictDecoder(data).Decode(&dst.Month)
	if err == nil {
		jsonMonth, _ := json.Marshal(dst.Month)
		if string(jsonMonth) == "{}" { // empty struct
			dst.Month = nil
		} else {
			if err = validator.Validate(dst.Month); err != nil {
				dst.Month = nil
			} else {
				match++
			}
		}
	} else {
		dst.Month = nil
	}

	// try to unmarshal data into MoreThan
	err = newStrictDecoder(data).Decode(&dst.MoreThan)
	if err == nil {
		jsonMoreThan, _ := json.Marshal(dst.MoreThan)
		if string(jsonMoreThan) == "{}" { // empty struct
			dst.MoreThan = nil
		} else {
			if err = validator.Validate(dst.MoreThan); err != nil {
				dst.MoreThan = nil
			} else {
				match++
			}
		}
	} else {
		dst.MoreThan = nil
	}

	// try to unmarshal data into MoreThanOrEqual
	err = newStrictDecoder(data).Decode(&dst.MoreThanOrEqual)
	if err == nil {
		jsonMoreThanOrEqual, _ := json.Marshal(dst.MoreThanOrEqual)
		if string(jsonMoreThanOrEqual) == "{}" { // empty struct
			dst.MoreThanOrEqual = nil
		} else {
			if err = validator.Validate(dst.MoreThanOrEqual); err != nil {
				dst.MoreThanOrEqual = nil
			} else {
				match++
			}
		}
	} else {
		dst.MoreThanOrEqual = nil
	}

	// try to unmarshal data into MultiplyNumbers
	err = newStrictDecoder(data).Decode(&dst.MultiplyNumbers)
	if err == nil {
		jsonMultiplyNumbers, _ := json.Marshal(dst.MultiplyNumbers)
		if string(jsonMultiplyNumbers) == "{}" { // empty struct
			dst.MultiplyNumbers = nil
		} else {
			if err = validator.Validate(dst.MultiplyNumbers); err != nil {
				dst.MultiplyNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.MultiplyNumbers = nil
	}

	// try to unmarshal data into Not
	err = newStrictDecoder(data).Decode(&dst.Not)
	if err == nil {
		jsonNot, _ := json.Marshal(dst.Not)
		if string(jsonNot) == "{}" { // empty struct
			dst.Not = nil
		} else {
			if err = validator.Validate(dst.Not); err != nil {
				dst.Not = nil
			} else {
				match++
			}
		}
	} else {
		dst.Not = nil
	}

	// try to unmarshal data into Now
	err = newStrictDecoder(data).Decode(&dst.Now)
	if err == nil {
		jsonNow, _ := json.Marshal(dst.Now)
		if string(jsonNow) == "{}" { // empty struct
			dst.Now = nil
		} else {
			if err = validator.Validate(dst.Now); err != nil {
				dst.Now = nil
			} else {
				match++
			}
		}
	} else {
		dst.Now = nil
	}

	// try to unmarshal data into NumberEquals
	err = newStrictDecoder(data).Decode(&dst.NumberEquals)
	if err == nil {
		jsonNumberEquals, _ := json.Marshal(dst.NumberEquals)
		if string(jsonNumberEquals) == "{}" { // empty struct
			dst.NumberEquals = nil
		} else {
			if err = validator.Validate(dst.NumberEquals); err != nil {
				dst.NumberEquals = nil
			} else {
				match++
			}
		}
	} else {
		dst.NumberEquals = nil
	}

	// try to unmarshal data into NumberPropertyVariable
	err = newStrictDecoder(data).Decode(&dst.NumberPropertyVariable)
	if err == nil {
		jsonNumberPropertyVariable, _ := json.Marshal(dst.NumberPropertyVariable)
		if string(jsonNumberPropertyVariable) == "{}" { // empty struct
			dst.NumberPropertyVariable = nil
		} else {
			if err = validator.Validate(dst.NumberPropertyVariable); err != nil {
				dst.NumberPropertyVariable = nil
			} else {
				match++
			}
		}
	} else {
		dst.NumberPropertyVariable = nil
	}

	// try to unmarshal data into NumberToString
	err = newStrictDecoder(data).Decode(&dst.NumberToString)
	if err == nil {
		jsonNumberToString, _ := json.Marshal(dst.NumberToString)
		if string(jsonNumberToString) == "{}" { // empty struct
			dst.NumberToString = nil
		} else {
			if err = validator.Validate(dst.NumberToString); err != nil {
				dst.NumberToString = nil
			} else {
				match++
			}
		}
	} else {
		dst.NumberToString = nil
	}

	// try to unmarshal data into Or
	err = newStrictDecoder(data).Decode(&dst.Or)
	if err == nil {
		jsonOr, _ := json.Marshal(dst.Or)
		if string(jsonOr) == "{}" { // empty struct
			dst.Or = nil
		} else {
			if err = validator.Validate(dst.Or); err != nil {
				dst.Or = nil
			} else {
				match++
			}
		}
	} else {
		dst.Or = nil
	}

	// try to unmarshal data into ParseNumber
	err = newStrictDecoder(data).Decode(&dst.ParseNumber)
	if err == nil {
		jsonParseNumber, _ := json.Marshal(dst.ParseNumber)
		if string(jsonParseNumber) == "{}" { // empty struct
			dst.ParseNumber = nil
		} else {
			if err = validator.Validate(dst.ParseNumber); err != nil {
				dst.ParseNumber = nil
			} else {
				match++
			}
		}
	} else {
		dst.ParseNumber = nil
	}

	// try to unmarshal data into PeriodToMonths
	err = newStrictDecoder(data).Decode(&dst.PeriodToMonths)
	if err == nil {
		jsonPeriodToMonths, _ := json.Marshal(dst.PeriodToMonths)
		if string(jsonPeriodToMonths) == "{}" { // empty struct
			dst.PeriodToMonths = nil
		} else {
			if err = validator.Validate(dst.PeriodToMonths); err != nil {
				dst.PeriodToMonths = nil
			} else {
				match++
			}
		}
	} else {
		dst.PeriodToMonths = nil
	}

	// try to unmarshal data into PipelineProbability
	err = newStrictDecoder(data).Decode(&dst.PipelineProbability)
	if err == nil {
		jsonPipelineProbability, _ := json.Marshal(dst.PipelineProbability)
		if string(jsonPipelineProbability) == "{}" { // empty struct
			dst.PipelineProbability = nil
		} else {
			if err = validator.Validate(dst.PipelineProbability); err != nil {
				dst.PipelineProbability = nil
			} else {
				match++
			}
		}
	} else {
		dst.PipelineProbability = nil
	}

	// try to unmarshal data into RoundDownNumbers
	err = newStrictDecoder(data).Decode(&dst.RoundDownNumbers)
	if err == nil {
		jsonRoundDownNumbers, _ := json.Marshal(dst.RoundDownNumbers)
		if string(jsonRoundDownNumbers) == "{}" { // empty struct
			dst.RoundDownNumbers = nil
		} else {
			if err = validator.Validate(dst.RoundDownNumbers); err != nil {
				dst.RoundDownNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.RoundDownNumbers = nil
	}

	// try to unmarshal data into RoundNearestNumbers
	err = newStrictDecoder(data).Decode(&dst.RoundNearestNumbers)
	if err == nil {
		jsonRoundNearestNumbers, _ := json.Marshal(dst.RoundNearestNumbers)
		if string(jsonRoundNearestNumbers) == "{}" { // empty struct
			dst.RoundNearestNumbers = nil
		} else {
			if err = validator.Validate(dst.RoundNearestNumbers); err != nil {
				dst.RoundNearestNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.RoundNearestNumbers = nil
	}

	// try to unmarshal data into RoundUpNumbers
	err = newStrictDecoder(data).Decode(&dst.RoundUpNumbers)
	if err == nil {
		jsonRoundUpNumbers, _ := json.Marshal(dst.RoundUpNumbers)
		if string(jsonRoundUpNumbers) == "{}" { // empty struct
			dst.RoundUpNumbers = nil
		} else {
			if err = validator.Validate(dst.RoundUpNumbers); err != nil {
				dst.RoundUpNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.RoundUpNumbers = nil
	}

	// try to unmarshal data into SetContainsString
	err = newStrictDecoder(data).Decode(&dst.SetContainsString)
	if err == nil {
		jsonSetContainsString, _ := json.Marshal(dst.SetContainsString)
		if string(jsonSetContainsString) == "{}" { // empty struct
			dst.SetContainsString = nil
		} else {
			if err = validator.Validate(dst.SetContainsString); err != nil {
				dst.SetContainsString = nil
			} else {
				match++
			}
		}
	} else {
		dst.SetContainsString = nil
	}

	// try to unmarshal data into StringEquals
	err = newStrictDecoder(data).Decode(&dst.StringEquals)
	if err == nil {
		jsonStringEquals, _ := json.Marshal(dst.StringEquals)
		if string(jsonStringEquals) == "{}" { // empty struct
			dst.StringEquals = nil
		} else {
			if err = validator.Validate(dst.StringEquals); err != nil {
				dst.StringEquals = nil
			} else {
				match++
			}
		}
	} else {
		dst.StringEquals = nil
	}

	// try to unmarshal data into StringPropertyVariable
	err = newStrictDecoder(data).Decode(&dst.StringPropertyVariable)
	if err == nil {
		jsonStringPropertyVariable, _ := json.Marshal(dst.StringPropertyVariable)
		if string(jsonStringPropertyVariable) == "{}" { // empty struct
			dst.StringPropertyVariable = nil
		} else {
			if err = validator.Validate(dst.StringPropertyVariable); err != nil {
				dst.StringPropertyVariable = nil
			} else {
				match++
			}
		}
	} else {
		dst.StringPropertyVariable = nil
	}

	// try to unmarshal data into SubtractNumbers
	err = newStrictDecoder(data).Decode(&dst.SubtractNumbers)
	if err == nil {
		jsonSubtractNumbers, _ := json.Marshal(dst.SubtractNumbers)
		if string(jsonSubtractNumbers) == "{}" { // empty struct
			dst.SubtractNumbers = nil
		} else {
			if err = validator.Validate(dst.SubtractNumbers); err != nil {
				dst.SubtractNumbers = nil
			} else {
				match++
			}
		}
	} else {
		dst.SubtractNumbers = nil
	}

	// try to unmarshal data into TimeBetween
	err = newStrictDecoder(data).Decode(&dst.TimeBetween)
	if err == nil {
		jsonTimeBetween, _ := json.Marshal(dst.TimeBetween)
		if string(jsonTimeBetween) == "{}" { // empty struct
			dst.TimeBetween = nil
		} else {
			if err = validator.Validate(dst.TimeBetween); err != nil {
				dst.TimeBetween = nil
			} else {
				match++
			}
		}
	} else {
		dst.TimeBetween = nil
	}

	// try to unmarshal data into TimestampOfPropertyVariable
	err = newStrictDecoder(data).Decode(&dst.TimestampOfPropertyVariable)
	if err == nil {
		jsonTimestampOfPropertyVariable, _ := json.Marshal(dst.TimestampOfPropertyVariable)
		if string(jsonTimestampOfPropertyVariable) == "{}" { // empty struct
			dst.TimestampOfPropertyVariable = nil
		} else {
			if err = validator.Validate(dst.TimestampOfPropertyVariable); err != nil {
				dst.TimestampOfPropertyVariable = nil
			} else {
				match++
			}
		}
	} else {
		dst.TimestampOfPropertyVariable = nil
	}

	// try to unmarshal data into UpperCase
	err = newStrictDecoder(data).Decode(&dst.UpperCase)
	if err == nil {
		jsonUpperCase, _ := json.Marshal(dst.UpperCase)
		if string(jsonUpperCase) == "{}" { // empty struct
			dst.UpperCase = nil
		} else {
			if err = validator.Validate(dst.UpperCase); err != nil {
				dst.UpperCase = nil
			} else {
				match++
			}
		}
	} else {
		dst.UpperCase = nil
	}

	// try to unmarshal data into Xor
	err = newStrictDecoder(data).Decode(&dst.Xor)
	if err == nil {
		jsonXor, _ := json.Marshal(dst.Xor)
		if string(jsonXor) == "{}" { // empty struct
			dst.Xor = nil
		} else {
			if err = validator.Validate(dst.Xor); err != nil {
				dst.Xor = nil
			} else {
				match++
			}
		}
	} else {
		dst.Xor = nil
	}

	// try to unmarshal data into Year
	err = newStrictDecoder(data).Decode(&dst.Year)
	if err == nil {
		jsonYear, _ := json.Marshal(dst.Year)
		if string(jsonYear) == "{}" { // empty struct
			dst.Year = nil
		} else {
			if err = validator.Validate(dst.Year); err != nil {
				dst.Year = nil
			} else {
				match++
			}
		}
	} else {
		dst.Year = nil
	}

	if match > 1 { // more than 1 match
		// reset to nil
		dst.AddNumbers = nil
		dst.And = nil
		dst.BeginsWith = nil
		dst.BooleanPropertyVariable = nil
		dst.ConcatStrings = nil
		dst.ConstantBoolean = nil
		dst.ConstantNumber = nil
		dst.ConstantString = nil
		dst.Contains = nil
		dst.Date = nil
		dst.DatedExchangeRate = nil
		dst.DivideNumbers = nil
		dst.ExtractMostRecentEmailReplyHtml = nil
		dst.ExtractMostRecentEmailReplyText = nil
		dst.ExtractMostRecentPlainTextEmailReply = nil
		dst.FetchCurrencyDecimalPlaces = nil
		dst.FetchExchangeRate = nil
		dst.FetchSingleCurrencyPortalCurrency = nil
		dst.FormatFullName = nil
		dst.HasEmailReply = nil
		dst.HasPlainTextEmailReply = nil
		dst.IfBoolean = nil
		dst.IfNumber = nil
		dst.IfString = nil
		dst.IsEngagementType = nil
		dst.IsPresent = nil
		dst.LessThan = nil
		dst.LessThanOrEqual = nil
		dst.LowerCase = nil
		dst.MaxNumbers = nil
		dst.MinNumbers = nil
		dst.Month = nil
		dst.MoreThan = nil
		dst.MoreThanOrEqual = nil
		dst.MultiplyNumbers = nil
		dst.Not = nil
		dst.Now = nil
		dst.NumberEquals = nil
		dst.NumberPropertyVariable = nil
		dst.NumberToString = nil
		dst.Or = nil
		dst.ParseNumber = nil
		dst.PeriodToMonths = nil
		dst.PipelineProbability = nil
		dst.RoundDownNumbers = nil
		dst.RoundNearestNumbers = nil
		dst.RoundUpNumbers = nil
		dst.SetContainsString = nil
		dst.StringEquals = nil
		dst.StringPropertyVariable = nil
		dst.SubtractNumbers = nil
		dst.TimeBetween = nil
		dst.TimestampOfPropertyVariable = nil
		dst.UpperCase = nil
		dst.Xor = nil
		dst.Year = nil

		return fmt.Errorf("data matches more than one schema in oneOf(OrInputsInner)")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("data failed to match schemas in oneOf(OrInputsInner)")
	}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src OrInputsInner) MarshalJSON() ([]byte, error) {
	if src.AddNumbers != nil {
		return json.Marshal(&src.AddNumbers)
	}

	if src.And != nil {
		return json.Marshal(&src.And)
	}

	if src.BeginsWith != nil {
		return json.Marshal(&src.BeginsWith)
	}

	if src.BooleanPropertyVariable != nil {
		return json.Marshal(&src.BooleanPropertyVariable)
	}

	if src.ConcatStrings != nil {
		return json.Marshal(&src.ConcatStrings)
	}

	if src.ConstantBoolean != nil {
		return json.Marshal(&src.ConstantBoolean)
	}

	if src.ConstantNumber != nil {
		return json.Marshal(&src.ConstantNumber)
	}

	if src.ConstantString != nil {
		return json.Marshal(&src.ConstantString)
	}

	if src.Contains != nil {
		return json.Marshal(&src.Contains)
	}

	if src.Date != nil {
		return json.Marshal(&src.Date)
	}

	if src.DatedExchangeRate != nil {
		return json.Marshal(&src.DatedExchangeRate)
	}

	if src.DivideNumbers != nil {
		return json.Marshal(&src.DivideNumbers)
	}

	if src.ExtractMostRecentEmailReplyHtml != nil {
		return json.Marshal(&src.ExtractMostRecentEmailReplyHtml)
	}

	if src.ExtractMostRecentEmailReplyText != nil {
		return json.Marshal(&src.ExtractMostRecentEmailReplyText)
	}

	if src.ExtractMostRecentPlainTextEmailReply != nil {
		return json.Marshal(&src.ExtractMostRecentPlainTextEmailReply)
	}

	if src.FetchCurrencyDecimalPlaces != nil {
		return json.Marshal(&src.FetchCurrencyDecimalPlaces)
	}

	if src.FetchExchangeRate != nil {
		return json.Marshal(&src.FetchExchangeRate)
	}

	if src.FetchSingleCurrencyPortalCurrency != nil {
		return json.Marshal(&src.FetchSingleCurrencyPortalCurrency)
	}

	if src.FormatFullName != nil {
		return json.Marshal(&src.FormatFullName)
	}

	if src.HasEmailReply != nil {
		return json.Marshal(&src.HasEmailReply)
	}

	if src.HasPlainTextEmailReply != nil {
		return json.Marshal(&src.HasPlainTextEmailReply)
	}

	if src.IfBoolean != nil {
		return json.Marshal(&src.IfBoolean)
	}

	if src.IfNumber != nil {
		return json.Marshal(&src.IfNumber)
	}

	if src.IfString != nil {
		return json.Marshal(&src.IfString)
	}

	if src.IsEngagementType != nil {
		return json.Marshal(&src.IsEngagementType)
	}

	if src.IsPresent != nil {
		return json.Marshal(&src.IsPresent)
	}

	if src.LessThan != nil {
		return json.Marshal(&src.LessThan)
	}

	if src.LessThanOrEqual != nil {
		return json.Marshal(&src.LessThanOrEqual)
	}

	if src.LowerCase != nil {
		return json.Marshal(&src.LowerCase)
	}

	if src.MaxNumbers != nil {
		return json.Marshal(&src.MaxNumbers)
	}

	if src.MinNumbers != nil {
		return json.Marshal(&src.MinNumbers)
	}

	if src.Month != nil {
		return json.Marshal(&src.Month)
	}

	if src.MoreThan != nil {
		return json.Marshal(&src.MoreThan)
	}

	if src.MoreThanOrEqual != nil {
		return json.Marshal(&src.MoreThanOrEqual)
	}

	if src.MultiplyNumbers != nil {
		return json.Marshal(&src.MultiplyNumbers)
	}

	if src.Not != nil {
		return json.Marshal(&src.Not)
	}

	if src.Now != nil {
		return json.Marshal(&src.Now)
	}

	if src.NumberEquals != nil {
		return json.Marshal(&src.NumberEquals)
	}

	if src.NumberPropertyVariable != nil {
		return json.Marshal(&src.NumberPropertyVariable)
	}

	if src.NumberToString != nil {
		return json.Marshal(&src.NumberToString)
	}

	if src.Or != nil {
		return json.Marshal(&src.Or)
	}

	if src.ParseNumber != nil {
		return json.Marshal(&src.ParseNumber)
	}

	if src.PeriodToMonths != nil {
		return json.Marshal(&src.PeriodToMonths)
	}

	if src.PipelineProbability != nil {
		return json.Marshal(&src.PipelineProbability)
	}

	if src.RoundDownNumbers != nil {
		return json.Marshal(&src.RoundDownNumbers)
	}

	if src.RoundNearestNumbers != nil {
		return json.Marshal(&src.RoundNearestNumbers)
	}

	if src.RoundUpNumbers != nil {
		return json.Marshal(&src.RoundUpNumbers)
	}

	if src.SetContainsString != nil {
		return json.Marshal(&src.SetContainsString)
	}

	if src.StringEquals != nil {
		return json.Marshal(&src.StringEquals)
	}

	if src.StringPropertyVariable != nil {
		return json.Marshal(&src.StringPropertyVariable)
	}

	if src.SubtractNumbers != nil {
		return json.Marshal(&src.SubtractNumbers)
	}

	if src.TimeBetween != nil {
		return json.Marshal(&src.TimeBetween)
	}

	if src.TimestampOfPropertyVariable != nil {
		return json.Marshal(&src.TimestampOfPropertyVariable)
	}

	if src.UpperCase != nil {
		return json.Marshal(&src.UpperCase)
	}

	if src.Xor != nil {
		return json.Marshal(&src.Xor)
	}

	if src.Year != nil {
		return json.Marshal(&src.Year)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *OrInputsInner) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
	if obj.AddNumbers != nil {
		return obj.AddNumbers
	}

	if obj.And != nil {
		return obj.And
	}

	if obj.BeginsWith != nil {
		return obj.BeginsWith
	}

	if obj.BooleanPropertyVariable != nil {
		return obj.BooleanPropertyVariable
	}

	if obj.ConcatStrings != nil {
		return obj.ConcatStrings
	}

	if obj.ConstantBoolean != nil {
		return obj.ConstantBoolean
	}

	if obj.ConstantNumber != nil {
		return obj.ConstantNumber
	}

	if obj.ConstantString != nil {
		return obj.ConstantString
	}

	if obj.Contains != nil {
		return obj.Contains
	}

	if obj.Date != nil {
		return obj.Date
	}

	if obj.DatedExchangeRate != nil {
		return obj.DatedExchangeRate
	}

	if obj.DivideNumbers != nil {
		return obj.DivideNumbers
	}

	if obj.ExtractMostRecentEmailReplyHtml != nil {
		return obj.ExtractMostRecentEmailReplyHtml
	}

	if obj.ExtractMostRecentEmailReplyText != nil {
		return obj.ExtractMostRecentEmailReplyText
	}

	if obj.ExtractMostRecentPlainTextEmailReply != nil {
		return obj.ExtractMostRecentPlainTextEmailReply
	}

	if obj.FetchCurrencyDecimalPlaces != nil {
		return obj.FetchCurrencyDecimalPlaces
	}

	if obj.FetchExchangeRate != nil {
		return obj.FetchExchangeRate
	}

	if obj.FetchSingleCurrencyPortalCurrency != nil {
		return obj.FetchSingleCurrencyPortalCurrency
	}

	if obj.FormatFullName != nil {
		return obj.FormatFullName
	}

	if obj.HasEmailReply != nil {
		return obj.HasEmailReply
	}

	if obj.HasPlainTextEmailReply != nil {
		return obj.HasPlainTextEmailReply
	}

	if obj.IfBoolean != nil {
		return obj.IfBoolean
	}

	if obj.IfNumber != nil {
		return obj.IfNumber
	}

	if obj.IfString != nil {
		return obj.IfString
	}

	if obj.IsEngagementType != nil {
		return obj.IsEngagementType
	}

	if obj.IsPresent != nil {
		return obj.IsPresent
	}

	if obj.LessThan != nil {
		return obj.LessThan
	}

	if obj.LessThanOrEqual != nil {
		return obj.LessThanOrEqual
	}

	if obj.LowerCase != nil {
		return obj.LowerCase
	}

	if obj.MaxNumbers != nil {
		return obj.MaxNumbers
	}

	if obj.MinNumbers != nil {
		return obj.MinNumbers
	}

	if obj.Month != nil {
		return obj.Month
	}

	if obj.MoreThan != nil {
		return obj.MoreThan
	}

	if obj.MoreThanOrEqual != nil {
		return obj.MoreThanOrEqual
	}

	if obj.MultiplyNumbers != nil {
		return obj.MultiplyNumbers
	}

	if obj.Not != nil {
		return obj.Not
	}

	if obj.Now != nil {
		return obj.Now
	}

	if obj.NumberEquals != nil {
		return obj.NumberEquals
	}

	if obj.NumberPropertyVariable != nil {
		return obj.NumberPropertyVariable
	}

	if obj.NumberToString != nil {
		return obj.NumberToString
	}

	if obj.Or != nil {
		return obj.Or
	}

	if obj.ParseNumber != nil {
		return obj.ParseNumber
	}

	if obj.PeriodToMonths != nil {
		return obj.PeriodToMonths
	}

	if obj.PipelineProbability != nil {
		return obj.PipelineProbability
	}

	if obj.RoundDownNumbers != nil {
		return obj.RoundDownNumbers
	}

	if obj.RoundNearestNumbers != nil {
		return obj.RoundNearestNumbers
	}

	if obj.RoundUpNumbers != nil {
		return obj.RoundUpNumbers
	}

	if obj.SetContainsString != nil {
		return obj.SetContainsString
	}

	if obj.StringEquals != nil {
		return obj.StringEquals
	}

	if obj.StringPropertyVariable != nil {
		return obj.StringPropertyVariable
	}

	if obj.SubtractNumbers != nil {
		return obj.SubtractNumbers
	}

	if obj.TimeBetween != nil {
		return obj.TimeBetween
	}

	if obj.TimestampOfPropertyVariable != nil {
		return obj.TimestampOfPropertyVariable
	}

	if obj.UpperCase != nil {
		return obj.UpperCase
	}

	if obj.Xor != nil {
		return obj.Xor
	}

	if obj.Year != nil {
		return obj.Year
	}

	// all schemas are nil
	return nil
}

// Get the actual instance value
func (obj OrInputsInner) GetActualInstanceValue() (interface{}) {
	if obj.AddNumbers != nil {
		return *obj.AddNumbers
	}

	if obj.And != nil {
		return *obj.And
	}

	if obj.BeginsWith != nil {
		return *obj.BeginsWith
	}

	if obj.BooleanPropertyVariable != nil {
		return *obj.BooleanPropertyVariable
	}

	if obj.ConcatStrings != nil {
		return *obj.ConcatStrings
	}

	if obj.ConstantBoolean != nil {
		return *obj.ConstantBoolean
	}

	if obj.ConstantNumber != nil {
		return *obj.ConstantNumber
	}

	if obj.ConstantString != nil {
		return *obj.ConstantString
	}

	if obj.Contains != nil {
		return *obj.Contains
	}

	if obj.Date != nil {
		return *obj.Date
	}

	if obj.DatedExchangeRate != nil {
		return *obj.DatedExchangeRate
	}

	if obj.DivideNumbers != nil {
		return *obj.DivideNumbers
	}

	if obj.ExtractMostRecentEmailReplyHtml != nil {
		return *obj.ExtractMostRecentEmailReplyHtml
	}

	if obj.ExtractMostRecentEmailReplyText != nil {
		return *obj.ExtractMostRecentEmailReplyText
	}

	if obj.ExtractMostRecentPlainTextEmailReply != nil {
		return *obj.ExtractMostRecentPlainTextEmailReply
	}

	if obj.FetchCurrencyDecimalPlaces != nil {
		return *obj.FetchCurrencyDecimalPlaces
	}

	if obj.FetchExchangeRate != nil {
		return *obj.FetchExchangeRate
	}

	if obj.FetchSingleCurrencyPortalCurrency != nil {
		return *obj.FetchSingleCurrencyPortalCurrency
	}

	if obj.FormatFullName != nil {
		return *obj.FormatFullName
	}

	if obj.HasEmailReply != nil {
		return *obj.HasEmailReply
	}

	if obj.HasPlainTextEmailReply != nil {
		return *obj.HasPlainTextEmailReply
	}

	if obj.IfBoolean != nil {
		return *obj.IfBoolean
	}

	if obj.IfNumber != nil {
		return *obj.IfNumber
	}

	if obj.IfString != nil {
		return *obj.IfString
	}

	if obj.IsEngagementType != nil {
		return *obj.IsEngagementType
	}

	if obj.IsPresent != nil {
		return *obj.IsPresent
	}

	if obj.LessThan != nil {
		return *obj.LessThan
	}

	if obj.LessThanOrEqual != nil {
		return *obj.LessThanOrEqual
	}

	if obj.LowerCase != nil {
		return *obj.LowerCase
	}

	if obj.MaxNumbers != nil {
		return *obj.MaxNumbers
	}

	if obj.MinNumbers != nil {
		return *obj.MinNumbers
	}

	if obj.Month != nil {
		return *obj.Month
	}

	if obj.MoreThan != nil {
		return *obj.MoreThan
	}

	if obj.MoreThanOrEqual != nil {
		return *obj.MoreThanOrEqual
	}

	if obj.MultiplyNumbers != nil {
		return *obj.MultiplyNumbers
	}

	if obj.Not != nil {
		return *obj.Not
	}

	if obj.Now != nil {
		return *obj.Now
	}

	if obj.NumberEquals != nil {
		return *obj.NumberEquals
	}

	if obj.NumberPropertyVariable != nil {
		return *obj.NumberPropertyVariable
	}

	if obj.NumberToString != nil {
		return *obj.NumberToString
	}

	if obj.Or != nil {
		return *obj.Or
	}

	if obj.ParseNumber != nil {
		return *obj.ParseNumber
	}

	if obj.PeriodToMonths != nil {
		return *obj.PeriodToMonths
	}

	if obj.PipelineProbability != nil {
		return *obj.PipelineProbability
	}

	if obj.RoundDownNumbers != nil {
		return *obj.RoundDownNumbers
	}

	if obj.RoundNearestNumbers != nil {
		return *obj.RoundNearestNumbers
	}

	if obj.RoundUpNumbers != nil {
		return *obj.RoundUpNumbers
	}

	if obj.SetContainsString != nil {
		return *obj.SetContainsString
	}

	if obj.StringEquals != nil {
		return *obj.StringEquals
	}

	if obj.StringPropertyVariable != nil {
		return *obj.StringPropertyVariable
	}

	if obj.SubtractNumbers != nil {
		return *obj.SubtractNumbers
	}

	if obj.TimeBetween != nil {
		return *obj.TimeBetween
	}

	if obj.TimestampOfPropertyVariable != nil {
		return *obj.TimestampOfPropertyVariable
	}

	if obj.UpperCase != nil {
		return *obj.UpperCase
	}

	if obj.Xor != nil {
		return *obj.Xor
	}

	if obj.Year != nil {
		return *obj.Year
	}

	// all schemas are nil
	return nil
}

type NullableOrInputsInner struct {
	value *OrInputsInner
	isSet bool
}

func (v NullableOrInputsInner) Get() *OrInputsInner {
	return v.value
}

func (v *NullableOrInputsInner) Set(val *OrInputsInner) {
	v.value = val
	v.isSet = true
}

func (v NullableOrInputsInner) IsSet() bool {
	return v.isSet
}

func (v *NullableOrInputsInner) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableOrInputsInner(val *OrInputsInner) *NullableOrInputsInner {
	return &NullableOrInputsInner{value: val, isSet: true}
}

func (v NullableOrInputsInner) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableOrInputsInner) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


