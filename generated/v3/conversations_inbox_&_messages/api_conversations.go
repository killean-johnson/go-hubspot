/*
Conversations Inbox & Messages

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package conversations_inbox_&amp;_messages

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/killean-johnson/go-hubspot"
"net/url"
	"strings"
	"reflect"
	"time"
)


// ConversationsAPIService ConversationsAPI service
type ConversationsAPIService service

type ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
}

func (r ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConversationsV3ConversationsThreadsThreadIdExecute(r)
}

/*
DeleteConversationsV3ConversationsThreadsThreadId Archives a thread.

Archives a single thread. The thread will be permanently deleted 30 days after placed in an archived state.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @return ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest
*/
func (a *ConversationsAPIService) DeleteConversationsV3ConversationsThreadsThreadId(ctx context.Context, threadId int64) ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest {
	return ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
	}
}

// Execute executes the request
func (a *ConversationsAPIService) DeleteConversationsV3ConversationsThreadsThreadIdExecute(r ApiDeleteConversationsV3ConversationsThreadsThreadIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.DeleteConversationsV3ConversationsThreadsThreadId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsActorsActorIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	actorId string
	property *string
}

func (r ApiGetConversationsV3ConversationsActorsActorIdRequest) Property(property string) ApiGetConversationsV3ConversationsActorsActorIdRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsActorsActorIdRequest) Execute() (*PublicActor, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsActorsActorIdExecute(r)
}

/*
GetConversationsV3ConversationsActorsActorId Get a single actor.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param actorId The unique ID of the actor.
 @return ApiGetConversationsV3ConversationsActorsActorIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsActorsActorId(ctx context.Context, actorId string) ApiGetConversationsV3ConversationsActorsActorIdRequest {
	return ApiGetConversationsV3ConversationsActorsActorIdRequest{
		ApiService: a,
		ctx: ctx,
		actorId: actorId,
	}
}

// Execute executes the request
//  @return PublicActor
func (a *ConversationsAPIService) GetConversationsV3ConversationsActorsActorIdExecute(r ApiGetConversationsV3ConversationsActorsActorIdRequest) (*PublicActor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsActorsActorId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/actors/{actorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"actorId"+"}", url.PathEscape(parameterValueToString(r.actorId, "actorId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsChannelAccountsRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	channelId *[]int32
	inboxId *[]int32
	after *string
	limit *int32
	sort *[]string
	defaultPageLength *int32
	archived *bool
}

// Limits results to channel accounts within a particular channel.
func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) ChannelId(channelId []int32) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.channelId = &channelId
	return r
}

// Limits results to channel accounts within a particular inbox.
func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) InboxId(inboxId []int32) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.inboxId = &inboxId
	return r
}

// The paging cursor token of the last successfully read resource will be returned as the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) After(after string) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.after = &after
	return r
}

// The maximum number of results to display per page.
func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) Limit(limit int32) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) Sort(sort []string) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) DefaultPageLength(defaultPageLength int32) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.defaultPageLength = &defaultPageLength
	return r
}

// 
func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) Archived(archived bool) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	r.archived = &archived
	return r
}

func (r ApiGetConversationsV3ConversationsChannelAccountsRequest) Execute() (*CollectionResponseWithTotalPublicChannelAccountForwardPaging, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsChannelAccountsExecute(r)
}

/*
GetConversationsV3ConversationsChannelAccounts Get channel accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsV3ConversationsChannelAccountsRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelAccounts(ctx context.Context) ApiGetConversationsV3ConversationsChannelAccountsRequest {
	return ApiGetConversationsV3ConversationsChannelAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalPublicChannelAccountForwardPaging
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelAccountsExecute(r ApiGetConversationsV3ConversationsChannelAccountsRequest) (*CollectionResponseWithTotalPublicChannelAccountForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalPublicChannelAccountForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsChannelAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/channel-accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		t := *r.channelId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", t, "form", "multi")
		}
	}
	if r.inboxId != nil {
		t := *r.inboxId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inboxId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inboxId", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.defaultPageLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPageLength", r.defaultPageLength, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	channelAccountId int64
	archived *bool
}

// 
func (r ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest) Archived(archived bool) ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest) Execute() (*PublicChannelAccount, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsChannelAccountsChannelAccountIdExecute(r)
}

/*
GetConversationsV3ConversationsChannelAccountsChannelAccountId Get a single channel account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelAccountId The unique ID of the channel account.
 @return ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelAccountsChannelAccountId(ctx context.Context, channelAccountId int64) ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest {
	return ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest{
		ApiService: a,
		ctx: ctx,
		channelAccountId: channelAccountId,
	}
}

// Execute executes the request
//  @return PublicChannelAccount
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelAccountsChannelAccountIdExecute(r ApiGetConversationsV3ConversationsChannelAccountsChannelAccountIdRequest) (*PublicChannelAccount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicChannelAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsChannelAccountsChannelAccountId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/channel-accounts/{channelAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelAccountId"+"}", url.PathEscape(parameterValueToString(r.channelAccountId, "channelAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue bool = false
		r.archived = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsChannelsRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	after *string
	limit *int32
	sort *[]string
	defaultPageLength *int32
}

// The paging cursor token of the last successfully read resource will be returned as the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetConversationsV3ConversationsChannelsRequest) After(after string) ApiGetConversationsV3ConversationsChannelsRequest {
	r.after = &after
	return r
}

// The maximum number of results to display per page.
func (r ApiGetConversationsV3ConversationsChannelsRequest) Limit(limit int32) ApiGetConversationsV3ConversationsChannelsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetConversationsV3ConversationsChannelsRequest) Sort(sort []string) ApiGetConversationsV3ConversationsChannelsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetConversationsV3ConversationsChannelsRequest) DefaultPageLength(defaultPageLength int32) ApiGetConversationsV3ConversationsChannelsRequest {
	r.defaultPageLength = &defaultPageLength
	return r
}

func (r ApiGetConversationsV3ConversationsChannelsRequest) Execute() (*CollectionResponseWithTotalPublicChannelForwardPaging, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsChannelsExecute(r)
}

/*
GetConversationsV3ConversationsChannels Get channels.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsV3ConversationsChannelsRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannels(ctx context.Context) ApiGetConversationsV3ConversationsChannelsRequest {
	return ApiGetConversationsV3ConversationsChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalPublicChannelForwardPaging
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelsExecute(r ApiGetConversationsV3ConversationsChannelsRequest) (*CollectionResponseWithTotalPublicChannelForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalPublicChannelForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.defaultPageLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPageLength", r.defaultPageLength, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsChannelsChannelIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	channelId int32
}

func (r ApiGetConversationsV3ConversationsChannelsChannelIdRequest) Execute() (*PublicChannel, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsChannelsChannelIdExecute(r)
}

/*
GetConversationsV3ConversationsChannelsChannelId Get a single channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId The unique ID of the channel.
 @return ApiGetConversationsV3ConversationsChannelsChannelIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelsChannelId(ctx context.Context, channelId int32) ApiGetConversationsV3ConversationsChannelsChannelIdRequest {
	return ApiGetConversationsV3ConversationsChannelsChannelIdRequest{
		ApiService: a,
		ctx: ctx,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return PublicChannel
func (a *ConversationsAPIService) GetConversationsV3ConversationsChannelsChannelIdExecute(r ApiGetConversationsV3ConversationsChannelsChannelIdRequest) (*PublicChannel, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicChannel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsChannelsChannelId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsInboxesRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	after *string
	limit *int32
	sort *[]string
	defaultPageLength *int32
	archived *bool
}

// The paging cursor token of the last successfully read resource will be returned as the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetConversationsV3ConversationsInboxesRequest) After(after string) ApiGetConversationsV3ConversationsInboxesRequest {
	r.after = &after
	return r
}

// The maximum number of results to display per page.
func (r ApiGetConversationsV3ConversationsInboxesRequest) Limit(limit int32) ApiGetConversationsV3ConversationsInboxesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetConversationsV3ConversationsInboxesRequest) Sort(sort []string) ApiGetConversationsV3ConversationsInboxesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetConversationsV3ConversationsInboxesRequest) DefaultPageLength(defaultPageLength int32) ApiGetConversationsV3ConversationsInboxesRequest {
	r.defaultPageLength = &defaultPageLength
	return r
}

// 
func (r ApiGetConversationsV3ConversationsInboxesRequest) Archived(archived bool) ApiGetConversationsV3ConversationsInboxesRequest {
	r.archived = &archived
	return r
}

func (r ApiGetConversationsV3ConversationsInboxesRequest) Execute() (*CollectionResponseWithTotalPublicInboxForwardPaging, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsInboxesExecute(r)
}

/*
GetConversationsV3ConversationsInboxes Get conversations inboxes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsV3ConversationsInboxesRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsInboxes(ctx context.Context) ApiGetConversationsV3ConversationsInboxesRequest {
	return ApiGetConversationsV3ConversationsInboxesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalPublicInboxForwardPaging
func (a *ConversationsAPIService) GetConversationsV3ConversationsInboxesExecute(r ApiGetConversationsV3ConversationsInboxesRequest) (*CollectionResponseWithTotalPublicInboxForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalPublicInboxForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsInboxes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/inboxes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.defaultPageLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultPageLength", r.defaultPageLength, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsInboxesInboxIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	inboxId int32
	archived *bool
}

// 
func (r ApiGetConversationsV3ConversationsInboxesInboxIdRequest) Archived(archived bool) ApiGetConversationsV3ConversationsInboxesInboxIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetConversationsV3ConversationsInboxesInboxIdRequest) Execute() (*PublicInbox, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsInboxesInboxIdExecute(r)
}

/*
GetConversationsV3ConversationsInboxesInboxId Get a single conversations inbox.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param inboxId The unique ID of the inbox.
 @return ApiGetConversationsV3ConversationsInboxesInboxIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsInboxesInboxId(ctx context.Context, inboxId int32) ApiGetConversationsV3ConversationsInboxesInboxIdRequest {
	return ApiGetConversationsV3ConversationsInboxesInboxIdRequest{
		ApiService: a,
		ctx: ctx,
		inboxId: inboxId,
	}
}

// Execute executes the request
//  @return PublicInbox
func (a *ConversationsAPIService) GetConversationsV3ConversationsInboxesInboxIdExecute(r ApiGetConversationsV3ConversationsInboxesInboxIdRequest) (*PublicInbox, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicInbox
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsInboxesInboxId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/inboxes/{inboxId}"
	localVarPath = strings.Replace(localVarPath, "{"+"inboxId"+"}", url.PathEscape(parameterValueToString(r.inboxId, "inboxId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	} else {
		var defaultValue bool = false
		r.archived = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsThreadsRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	after *string
	limit *int32
	sort *[]string
	inboxId *[]int32
	associatedContactId *int64
	threadStatus *string
	latestMessageTimestampAfter *time.Time
	archived *bool
	association *[]string
	property *string
}

// The paging cursor token of the last successfully read resource will be returned as the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetConversationsV3ConversationsThreadsRequest) After(after string) ApiGetConversationsV3ConversationsThreadsRequest {
	r.after = &after
	return r
}

// The maximum number of results to display per page.
func (r ApiGetConversationsV3ConversationsThreadsRequest) Limit(limit int32) ApiGetConversationsV3ConversationsThreadsRequest {
	r.limit = &limit
	return r
}

// Set the sort order of the response. Valid options are &#x60;id&#x60; (default) and &#x60;latestMessageTimestamp&#x60; (which requires the &#x60;latestMessageTimestampAfter&#x60; field to also be set). If you’re filtering threads by &#x60;associatedContactId&#x60; , you can sort in descending order by prepending - to the sort option (e.g., &#x60;-id&#x60; or &#x60;-latestMessageTimestampAfter&#x60; ). Otherwise, results are always returned in ascending order.
func (r ApiGetConversationsV3ConversationsThreadsRequest) Sort(sort []string) ApiGetConversationsV3ConversationsThreadsRequest {
	r.sort = &sort
	return r
}

// The ID of the conversations inbox you can optionally include to retrieve the associated messages for. This parameter cannot be used in conjunction with the &#x60;associatedContactId&#x60; property.
func (r ApiGetConversationsV3ConversationsThreadsRequest) InboxId(inboxId []int32) ApiGetConversationsV3ConversationsThreadsRequest {
	r.inboxId = &inboxId
	return r
}

// The ID of a contact you can optionally include to retrieve a filtered list of conversations for. This parameter cannot be used in conjunction with the &#x60;inboxId&#x60; property.
func (r ApiGetConversationsV3ConversationsThreadsRequest) AssociatedContactId(associatedContactId int64) ApiGetConversationsV3ConversationsThreadsRequest {
	r.associatedContactId = &associatedContactId
	return r
}

// The status of the associated conversations to filter by (either &#x60;OPEN&#x60; or &#x60;CLOSED&#x60;). This property must be provided if you’re including the &#x60;associatedContactId&#x60; query parameter.
func (r ApiGetConversationsV3ConversationsThreadsRequest) ThreadStatus(threadStatus string) ApiGetConversationsV3ConversationsThreadsRequest {
	r.threadStatus = &threadStatus
	return r
}

// The minimum &#x60;latestMessageTimestamp&#x60;. This is required only when sorting by &#x60;latestMessageTimestamp&#x60;.
func (r ApiGetConversationsV3ConversationsThreadsRequest) LatestMessageTimestampAfter(latestMessageTimestampAfter time.Time) ApiGetConversationsV3ConversationsThreadsRequest {
	r.latestMessageTimestampAfter = &latestMessageTimestampAfter
	return r
}

// Whether to return only results that have been archived.
func (r ApiGetConversationsV3ConversationsThreadsRequest) Archived(archived bool) ApiGetConversationsV3ConversationsThreadsRequest {
	r.archived = &archived
	return r
}

// You can specify an association type here of &#x60;TICKET&#x60;. If this is set the response will included a thread associations object and associated ticket id if present. If there are no associations to a ticket with this conversation, then the thread associations object will not be present on the response. 
func (r ApiGetConversationsV3ConversationsThreadsRequest) Association(association []string) ApiGetConversationsV3ConversationsThreadsRequest {
	r.association = &association
	return r
}

// 
func (r ApiGetConversationsV3ConversationsThreadsRequest) Property(property string) ApiGetConversationsV3ConversationsThreadsRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsRequest) Execute() (*CollectionResponsePublicThreadForwardPaging, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsThreadsExecute(r)
}

/*
GetConversationsV3ConversationsThreads Get threads.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetConversationsV3ConversationsThreadsRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreads(ctx context.Context) ApiGetConversationsV3ConversationsThreadsRequest {
	return ApiGetConversationsV3ConversationsThreadsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponsePublicThreadForwardPaging
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsExecute(r ApiGetConversationsV3ConversationsThreadsRequest) (*CollectionResponsePublicThreadForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponsePublicThreadForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsThreads")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.inboxId != nil {
		t := *r.inboxId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "inboxId", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "inboxId", t, "form", "multi")
		}
	}
	if r.associatedContactId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "associatedContactId", r.associatedContactId, "form", "")
	}
	if r.threadStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "threadStatus", r.threadStatus, "form", "")
	}
	if r.latestMessageTimestampAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latestMessageTimestampAfter", r.latestMessageTimestampAfter, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.association != nil {
		t := *r.association
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "association", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "association", t, "form", "multi")
		}
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsThreadsThreadIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	archived *bool
	association *[]string
	property *string
}

// Whether to return only results that have been archived. Default is false.
func (r ApiGetConversationsV3ConversationsThreadsThreadIdRequest) Archived(archived bool) ApiGetConversationsV3ConversationsThreadsThreadIdRequest {
	r.archived = &archived
	return r
}

// You can specify an association type here of &#x60;TICKET&#x60;. If this is set the response will included a thread associations object and associated ticket id if present. If there are no associations to a ticket with this conversation, then the thread associations object will not be present on the response. 
func (r ApiGetConversationsV3ConversationsThreadsThreadIdRequest) Association(association []string) ApiGetConversationsV3ConversationsThreadsThreadIdRequest {
	r.association = &association
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdRequest) Property(property string) ApiGetConversationsV3ConversationsThreadsThreadIdRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdRequest) Execute() (*PublicThread, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsThreadsThreadIdExecute(r)
}

/*
GetConversationsV3ConversationsThreadsThreadId Get a single thread.

Returns a single thread.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @return ApiGetConversationsV3ConversationsThreadsThreadIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadId(ctx context.Context, threadId int64) ApiGetConversationsV3ConversationsThreadsThreadIdRequest {
	return ApiGetConversationsV3ConversationsThreadsThreadIdRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
	}
}

// Execute executes the request
//  @return PublicThread
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdExecute(r ApiGetConversationsV3ConversationsThreadsThreadIdRequest) (*PublicThread, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsThreadsThreadId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.association != nil {
		t := *r.association
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "association", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "association", t, "form", "multi")
		}
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	after *string
	limit *int32
	sort *[]string
	archived *bool
	property *string
}

// The paging cursor token of the last successfully read resource will be returned as the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) After(after string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.after = &after
	return r
}

// The maximum number of results to display per page.
func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) Limit(limit int32) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.limit = &limit
	return r
}

// Sort direction. Valid options are &#x60;createdAt&#x60; (ascending), and &#x60;-createdAt&#x60; (descending, default)
func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) Sort(sort []string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.sort = &sort
	return r
}

// Whether to return only results that have been archived.
func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) Archived(archived bool) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.archived = &archived
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) Property(property string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) Execute() (*CollectionResponsePublicMessageForwardPaging, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsThreadsThreadIdMessagesExecute(r)
}

/*
GetConversationsV3ConversationsThreadsThreadIdMessages Get message history for a thread.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessages(ctx context.Context, threadId int64) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
	}
}

// Execute executes the request
//  @return CollectionResponsePublicMessageForwardPaging
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessagesExecute(r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesRequest) (*CollectionResponsePublicMessageForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponsePublicMessageForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsThreadsThreadIdMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	messageId string
	property *string
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest) Property(property string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest) Execute() (*PublicMessage, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdExecute(r)
}

/*
GetConversationsV3ConversationsThreadsThreadIdMessagesMessageId Get a single message.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @param messageId The unique ID of the message.
 @return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessagesMessageId(ctx context.Context, threadId int64, messageId string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest {
	return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return PublicMessage
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdExecute(r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdRequest) (*PublicMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsThreadsThreadIdMessagesMessageId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	messageId string
	property *string
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest) Property(property string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest {
	r.property = &property
	return r
}

func (r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest) Execute() (*PublicMessageContent, *http.Response, error) {
	return r.ApiService.GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentExecute(r)
}

/*
GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContent Get the original content of a single message.

Returns the complete original text and rich text bodies of a message. This will be different from the text and rich text in the message itself if the message's `truncationStatus` is anything other than `NOT_TRUNCATED`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @param messageId The unique ID of the message.
 @return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest
*/
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContent(ctx context.Context, threadId int64, messageId string) ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest {
	return ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return PublicMessageContent
func (a *ConversationsAPIService) GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentExecute(r ApiGetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContentRequest) (*PublicMessageContent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicMessageContent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.GetConversationsV3ConversationsThreadsThreadIdMessagesMessageIdOriginalContent")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}/messages/{messageId}/original-content"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchConversationsV3ConversationsThreadsThreadIdRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	publicThreadUpdateRequest *PublicThreadUpdateRequest
	archived *bool
}

func (r ApiPatchConversationsV3ConversationsThreadsThreadIdRequest) PublicThreadUpdateRequest(publicThreadUpdateRequest PublicThreadUpdateRequest) ApiPatchConversationsV3ConversationsThreadsThreadIdRequest {
	r.publicThreadUpdateRequest = &publicThreadUpdateRequest
	return r
}

// Whether the thread to update is archived. Default is false. A thread&#39;s status property can not be updated if the thread is archived.
func (r ApiPatchConversationsV3ConversationsThreadsThreadIdRequest) Archived(archived bool) ApiPatchConversationsV3ConversationsThreadsThreadIdRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchConversationsV3ConversationsThreadsThreadIdRequest) Execute() (*PublicThread, *http.Response, error) {
	return r.ApiService.PatchConversationsV3ConversationsThreadsThreadIdExecute(r)
}

/*
PatchConversationsV3ConversationsThreadsThreadId Update a thread.

Updates a single thread. Either a thread's status can be updated, or the thread can be restored.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @return ApiPatchConversationsV3ConversationsThreadsThreadIdRequest
*/
func (a *ConversationsAPIService) PatchConversationsV3ConversationsThreadsThreadId(ctx context.Context, threadId int64) ApiPatchConversationsV3ConversationsThreadsThreadIdRequest {
	return ApiPatchConversationsV3ConversationsThreadsThreadIdRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
	}
}

// Execute executes the request
//  @return PublicThread
func (a *ConversationsAPIService) PatchConversationsV3ConversationsThreadsThreadIdExecute(r ApiPatchConversationsV3ConversationsThreadsThreadIdRequest) (*PublicThread, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicThread
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.PatchConversationsV3ConversationsThreadsThreadId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicThreadUpdateRequest == nil {
		return localVarReturnValue, nil, reportError("publicThreadUpdateRequest is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicThreadUpdateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostConversationsV3ConversationsActorsBatchReadRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	batchInputString *BatchInputString
	property *string
}

func (r ApiPostConversationsV3ConversationsActorsBatchReadRequest) BatchInputString(batchInputString BatchInputString) ApiPostConversationsV3ConversationsActorsBatchReadRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostConversationsV3ConversationsActorsBatchReadRequest) Property(property string) ApiPostConversationsV3ConversationsActorsBatchReadRequest {
	r.property = &property
	return r
}

func (r ApiPostConversationsV3ConversationsActorsBatchReadRequest) Execute() (*BatchResponsePublicActor, *http.Response, error) {
	return r.ApiService.PostConversationsV3ConversationsActorsBatchReadExecute(r)
}

/*
PostConversationsV3ConversationsActorsBatchRead Get actors

Resolve `ActorId`s to the underlying actors/participants.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostConversationsV3ConversationsActorsBatchReadRequest
*/
func (a *ConversationsAPIService) PostConversationsV3ConversationsActorsBatchRead(ctx context.Context) ApiPostConversationsV3ConversationsActorsBatchReadRequest {
	return ApiPostConversationsV3ConversationsActorsBatchReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicActor
func (a *ConversationsAPIService) PostConversationsV3ConversationsActorsBatchReadExecute(r ApiPostConversationsV3ConversationsActorsBatchReadRequest) (*BatchResponsePublicActor, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicActor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.PostConversationsV3ConversationsActorsBatchRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/actors/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest struct {
	ctx context.Context
	ApiService *ConversationsAPIService
	threadId int64
	publicMessageEgg *PublicMessageEgg
}

func (r ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest) PublicMessageEgg(publicMessageEgg PublicMessageEgg) ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	r.publicMessageEgg = &publicMessageEgg
	return r
}

func (r ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest) Execute() (*PublicMessage, *http.Response, error) {
	return r.ApiService.PostConversationsV3ConversationsThreadsThreadIdMessagesExecute(r)
}

/*
PostConversationsV3ConversationsThreadsThreadIdMessages Send a message to a thread.

Send a new message on a thread at the current timestamp.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param threadId The unique ID of the thread.
 @return ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest
*/
func (a *ConversationsAPIService) PostConversationsV3ConversationsThreadsThreadIdMessages(ctx context.Context, threadId int64) ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest {
	return ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest{
		ApiService: a,
		ctx: ctx,
		threadId: threadId,
	}
}

// Execute executes the request
//  @return PublicMessage
func (a *ConversationsAPIService) PostConversationsV3ConversationsThreadsThreadIdMessagesExecute(r ApiPostConversationsV3ConversationsThreadsThreadIdMessagesRequest) (*PublicMessage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicMessage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConversationsAPIService.PostConversationsV3ConversationsThreadsThreadIdMessages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversations/v3/conversations/threads/{threadId}/messages"
	localVarPath = strings.Replace(localVarPath, "{"+"threadId"+"}", url.PathEscape(parameterValueToString(r.threadId, "threadId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicMessageEgg == nil {
		return localVarReturnValue, nil, reportError("publicMessageEgg is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicMessageEgg
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
