/*
Blog Settings

\"Use these endpoints for interacting with Blog objects\"

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package blog_settings

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/killean-johnson/go-hubspot"
"net/url"
	"strings"
	"time"
	"reflect"
)


// BlogsAPIService BlogsAPI service
type BlogsAPIService service

type ApiGetCmsV3BlogSettingsSettingsRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	createdAt *time.Time
	createdAfter *time.Time
	createdBefore *time.Time
	updatedAt *time.Time
	updatedAfter *time.Time
	updatedBefore *time.Time
	sort *[]string
	after *string
	limit *int32
	archived *bool
}

// Only return Blogs created at exactly the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Blogs created after the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Blogs created before the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Blogs last updated at exactly the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Blogs last updated after the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Blogs last updated before the specified time.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60; and &#x60;id&#x60;
func (r ApiGetCmsV3BlogSettingsSettingsRequest) Sort(sort []string) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) After(after string) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) Limit(limit int32) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return archived Blogs. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3BlogSettingsSettingsRequest) Archived(archived bool) ApiGetCmsV3BlogSettingsSettingsRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3BlogSettingsSettingsRequest) Execute() (*CollectionResponseWithTotalBlogForwardPaging, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogSettingsSettingsExecute(r)
}

/*
GetCmsV3BlogSettingsSettings Get all Blogs

Get the list of Blogs. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3BlogSettingsSettingsRequest
*/
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettings(ctx context.Context) ApiGetCmsV3BlogSettingsSettingsRequest {
	return ApiGetCmsV3BlogSettingsSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalBlogForwardPaging
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsExecute(r ApiGetCmsV3BlogSettingsSettingsRequest) (*CollectionResponseWithTotalBlogForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalBlogForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.GetCmsV3BlogSettingsSettings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "form", "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogSettingsSettingsBlogIdRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	blogId string
}

func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRequest) Execute() (*Blog, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogSettingsSettingsBlogIdExecute(r)
}

/*
GetCmsV3BlogSettingsSettingsBlogId Retrieve a Blog

Retrieve the Blog object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogId The Blog id.
 @return ApiGetCmsV3BlogSettingsSettingsBlogIdRequest
*/
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogId(ctx context.Context, blogId string) ApiGetCmsV3BlogSettingsSettingsBlogIdRequest {
	return ApiGetCmsV3BlogSettingsSettingsBlogIdRequest{
		ApiService: a,
		ctx: ctx,
		blogId: blogId,
	}
}

// Execute executes the request
//  @return Blog
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogIdExecute(r ApiGetCmsV3BlogSettingsSettingsBlogIdRequest) (*Blog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Blog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.GetCmsV3BlogSettingsSettingsBlogId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/{blogId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogId"+"}", url.PathEscape(parameterValueToString(r.blogId, "blogId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	blogId string
	after *string
	before *string
	limit *int32
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest) After(after string) ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest {
	r.after = &after
	return r
}

func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest) Before(before string) ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest {
	r.before = &before
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest) Limit(limit int32) ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest) Execute() (*CollectionResponseWithTotalVersionBlog, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogSettingsSettingsBlogIdRevisionsExecute(r)
}

/*
GetCmsV3BlogSettingsSettingsBlogIdRevisions Retrieves all the previous versions of a Blog

Retrieves all the previous versions of a Blog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogId The Blog id.
 @return ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest
*/
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogIdRevisions(ctx context.Context, blogId string) ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest {
	return ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest{
		ApiService: a,
		ctx: ctx,
		blogId: blogId,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalVersionBlog
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogIdRevisionsExecute(r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRequest) (*CollectionResponseWithTotalVersionBlog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalVersionBlog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.GetCmsV3BlogSettingsSettingsBlogIdRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/{blogId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"blogId"+"}", url.PathEscape(parameterValueToString(r.blogId, "blogId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	blogId string
	revisionId string
}

func (r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest) Execute() (*VersionBlog, *http.Response, error) {
	return r.ApiService.GetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdExecute(r)
}

/*
GetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionId Retrieves a previous version of a Blog

Retrieves a previous version of a Blog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blogId The Blog id.
 @param revisionId The Blog version id.
 @return ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest
*/
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionId(ctx context.Context, blogId string, revisionId string) ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest {
	return ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest{
		ApiService: a,
		ctx: ctx,
		blogId: blogId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return VersionBlog
func (a *BlogsAPIService) GetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdExecute(r ApiGetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionIdRequest) (*VersionBlog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionBlog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.GetCmsV3BlogSettingsSettingsBlogIdRevisionsRevisionId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/{blogId}/revisions/{revisionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"blogId"+"}", url.PathEscape(parameterValueToString(r.blogId, "blogId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	attachToLangPrimaryRequestVNext *AttachToLangPrimaryRequestVNext
}

// The JSON representation of the AttachToLangPrimaryRequest object.
func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest) AttachToLangPrimaryRequestVNext(attachToLangPrimaryRequestVNext AttachToLangPrimaryRequestVNext) ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest {
	r.attachToLangPrimaryRequestVNext = &attachToLangPrimaryRequestVNext
	return r
}

func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupExecute(r)
}

/*
PostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroup Attach a blog to a multi-language group

Attach a blog to a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest
*/
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroup(ctx context.Context) ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest {
	return ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupExecute(r ApiPostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.PostCmsV3BlogSettingsSettingsMultiLanguageAttachToLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/multi-language/attach-to-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachToLangPrimaryRequestVNext == nil {
		return nil, reportError("attachToLangPrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachToLangPrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	blogLanguageCloneRequestVNext *BlogLanguageCloneRequestVNext
}

// The JSON representation of the ContentLanguageCloneRequest object.
func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest) BlogLanguageCloneRequestVNext(blogLanguageCloneRequestVNext BlogLanguageCloneRequestVNext) ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest {
	r.blogLanguageCloneRequestVNext = &blogLanguageCloneRequestVNext
	return r
}

func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest) Execute() (*Blog, *http.Response, error) {
	return r.ApiService.PostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationExecute(r)
}

/*
PostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariation Create a new language variation

Create a new language variation from an existing blog

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest
*/
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariation(ctx context.Context) ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest {
	return ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Blog
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationExecute(r ApiPostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariationRequest) (*Blog, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Blog
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.PostCmsV3BlogSettingsSettingsMultiLanguageCreateLanguageVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/multi-language/create-language-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.blogLanguageCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("blogLanguageCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.blogLanguageCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	detachFromLangGroupRequestVNext *DetachFromLangGroupRequestVNext
}

// The JSON representation of the DetachFromLangGroupRequest object.
func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest) DetachFromLangGroupRequestVNext(detachFromLangGroupRequestVNext DetachFromLangGroupRequestVNext) ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest {
	r.detachFromLangGroupRequestVNext = &detachFromLangGroupRequestVNext
	return r
}

func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupExecute(r)
}

/*
PostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroup Detach a blog from a multi-language group

Detach a blog from a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest
*/
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroup(ctx context.Context) ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest {
	return ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupExecute(r ApiPostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.PostCmsV3BlogSettingsSettingsMultiLanguageDetachFromLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/multi-language/detach-from-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.detachFromLangGroupRequestVNext == nil {
		return nil, reportError("detachFromLangGroupRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.detachFromLangGroupRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	updateLanguagesRequestVNext *UpdateLanguagesRequestVNext
}

// The JSON representation of the UpdateLanguagesRequest object.
func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest) UpdateLanguagesRequestVNext(updateLanguagesRequestVNext UpdateLanguagesRequestVNext) ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest {
	r.updateLanguagesRequestVNext = &updateLanguagesRequestVNext
	return r
}

func (r ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesExecute(r)
}

/*
PostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguages Update languages of multi-language group

Explicitly set new languages for each blog in a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest
*/
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguages(ctx context.Context) ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest {
	return ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlogsAPIService) PostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesExecute(r ApiPostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguagesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.PostCmsV3BlogSettingsSettingsMultiLanguageUpdateLanguages")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/multi-language/update-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLanguagesRequestVNext == nil {
		return nil, reportError("updateLanguagesRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLanguagesRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest struct {
	ctx context.Context
	ApiService *BlogsAPIService
	setNewLanguagePrimaryRequestVNext *SetNewLanguagePrimaryRequestVNext
}

// The JSON representation of the SetNewLanguagePrimaryRequest object.
func (r ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest) SetNewLanguagePrimaryRequestVNext(setNewLanguagePrimaryRequestVNext SetNewLanguagePrimaryRequestVNext) ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest {
	r.setNewLanguagePrimaryRequestVNext = &setNewLanguagePrimaryRequestVNext
	return r
}

func (r ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryExecute(r)
}

/*
PutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimary Set a new primary language

Set a blog as the primary language of a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest
*/
func (a *BlogsAPIService) PutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimary(ctx context.Context) ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest {
	return ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlogsAPIService) PutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryExecute(r ApiPutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlogsAPIService.PutCmsV3BlogSettingsSettingsMultiLanguageSetNewLangPrimary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/blog-settings/settings/multi-language/set-new-lang-primary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setNewLanguagePrimaryRequestVNext == nil {
		return nil, reportError("setNewLanguagePrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setNewLanguagePrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
