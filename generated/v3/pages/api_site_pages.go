/*
Pages

Use these endpoints for interacting with Landing Pages and Site Pages

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pages

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/killean-johnson/go-hubspot"
"net/url"
	"strings"
	"time"
	"reflect"
)


// SitePagesAPIService SitePagesAPI service
type SitePagesAPIService service

type ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	archived *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest) Archived(archived bool) ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCmsV3PagesSitePagesObjectIdArchiveExecute(r)
}

/*
DeleteCmsV3PagesSitePagesObjectIdArchive Delete a Site Page

Delete the Site Page object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest
*/
func (a *SitePagesAPIService) DeleteCmsV3PagesSitePagesObjectIdArchive(ctx context.Context, objectId string) ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest {
	return ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) DeleteCmsV3PagesSitePagesObjectIdArchiveExecute(r ApiDeleteCmsV3PagesSitePagesObjectIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.DeleteCmsV3PagesSitePagesObjectIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesSitePagesGetPageRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	createdAt *time.Time
	createdAfter *time.Time
	createdBefore *time.Time
	updatedAt *time.Time
	updatedAfter *time.Time
	updatedBefore *time.Time
	sort *[]string
	after *string
	limit *int32
	archived *bool
	property *string
}

// Only return Site Pages created at exactly the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Site Pages created after the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Site Pages created before the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Site Pages last updated at exactly the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Site Pages last updated after the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Site Pages last updated before the specified time.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) Sort(sort []string) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) After(after string) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) Limit(limit int32) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return deleted Site Pages. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesSitePagesGetPageRequest) Archived(archived bool) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesSitePagesGetPageRequest) Property(property string) ApiGetCmsV3PagesSitePagesGetPageRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesSitePagesGetPageRequest) Execute() (*CollectionResponseWithTotalPageForwardPaging, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesSitePagesGetPageExecute(r)
}

/*
GetCmsV3PagesSitePagesGetPage Get all Site Pages

Get the list of site pages. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3PagesSitePagesGetPageRequest
*/
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesGetPage(ctx context.Context) ApiGetCmsV3PagesSitePagesGetPageRequest {
	return ApiGetCmsV3PagesSitePagesGetPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalPageForwardPaging
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesGetPageExecute(r ApiGetCmsV3PagesSitePagesGetPageRequest) (*CollectionResponseWithTotalPageForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalPageForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.GetCmsV3PagesSitePagesGetPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "form", "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
}

func (r ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdExecute(r)
}

/*
GetCmsV3PagesSitePagesObjectIdDraftGetDraftById Retrieve the full draft version of the Site Page

Retrieve the full draft version of the Site Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest
*/
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdDraftGetDraftById(ctx context.Context, objectId string) ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest {
	return ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdExecute(r ApiGetCmsV3PagesSitePagesObjectIdDraftGetDraftByIdRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.GetCmsV3PagesSitePagesObjectIdDraftGetDraftById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	archived *bool
	property *string
}

// Specifies whether to return deleted Site Pages. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest) Archived(archived bool) ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest) Property(property string) ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesSitePagesObjectIdGetByIdExecute(r)
}

/*
GetCmsV3PagesSitePagesObjectIdGetById Retrieve a Site Page

Retrieve the Site Page object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest
*/
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdGetById(ctx context.Context, objectId string) ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest {
	return ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdGetByIdExecute(r ApiGetCmsV3PagesSitePagesObjectIdGetByIdRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.GetCmsV3PagesSitePagesObjectIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	after *string
	before *string
	limit *int32
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest) After(after string) ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.after = &after
	return r
}

func (r ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest) Before(before string) ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.before = &before
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest) Limit(limit int32) ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest) Execute() (*CollectionResponseWithTotalVersionPage, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsExecute(r)
}

/*
GetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersions Retrieves all the previous versions of a Site Page

Retrieves all the previous versions of a Site Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest
*/
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersions(ctx context.Context, objectId string) ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest {
	return ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalVersionPage
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsExecute(r ApiGetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersionsRequest) (*CollectionResponseWithTotalVersionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalVersionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.GetCmsV3PagesSitePagesObjectIdRevisionsGetPreviousVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	revisionId string
}

func (r ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest) Execute() (*VersionPage, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r)
}

/*
GetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersion Retrieves a previous version of a Site Page

Retrieves a previous version of a Site Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @param revisionId The Site Page version id.
 @return ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest
*/
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersion(ctx context.Context, objectId string, revisionId string) ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest {
	return ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return VersionPage
func (a *SitePagesAPIService) GetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r ApiGetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest) (*VersionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.GetCmsV3PagesSitePagesObjectIdRevisionsRevisionIdGetPreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/revisions/{revisionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	page *Page
}

// The JSON representation of the updated Site Page to be applied to the draft.
func (r ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest) Page(page Page) ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest {
	r.page = &page
	return r
}

func (r ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftExecute(r)
}

/*
PatchCmsV3PagesSitePagesObjectIdDraftUpdateDraft Update a Site Page draft

Sparse updates the draft version of a single Site Page object identified by the id in the path.
You only need to specify the column values that you are modifying.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest
*/
func (a *SitePagesAPIService) PatchCmsV3PagesSitePagesObjectIdDraftUpdateDraft(ctx context.Context, objectId string) ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest {
	return ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftExecute(r ApiPatchCmsV3PagesSitePagesObjectIdDraftUpdateDraftRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PatchCmsV3PagesSitePagesObjectIdDraftUpdateDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	page *Page
	archived *bool
}

// The JSON representation of the updated Site Page.
func (r ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest) Page(page Page) ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest {
	r.page = &page
	return r
}

// Specifies whether to update deleted Site Pages. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest) Archived(archived bool) ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PatchCmsV3PagesSitePagesObjectIdUpdateExecute(r)
}

/*
PatchCmsV3PagesSitePagesObjectIdUpdate Update a Site Page

Sparse updates a single Site Page object identified by the id in the path.
You only need to specify the column values that you are modifying.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @return ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest
*/
func (a *SitePagesAPIService) PatchCmsV3PagesSitePagesObjectIdUpdate(ctx context.Context, objectId string) ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest {
	return ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PatchCmsV3PagesSitePagesObjectIdUpdateExecute(r ApiPatchCmsV3PagesSitePagesObjectIdUpdateRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PatchCmsV3PagesSitePagesObjectIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	abTestCreateRequestVNext *AbTestCreateRequestVNext
}

// The JSON representation of the AbTestCreateRequest object.
func (r ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest) AbTestCreateRequestVNext(abTestCreateRequestVNext AbTestCreateRequestVNext) ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest {
	r.abTestCreateRequestVNext = &abTestCreateRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationExecute(r)
}

/*
PostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariation Create a new A/B test variation

Create a new A/B test variation based on the information provided in the request body.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariation(ctx context.Context) ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest {
	return ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationExecute(r ApiPostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariationRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesAbTestCreateVariationCreateABTestVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/ab-test/create-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestCreateRequestVNext == nil {
		return localVarReturnValue, nil, reportError("abTestCreateRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestCreateRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	abTestEndRequestVNext *AbTestEndRequestVNext
}

// The JSON representation of the AbTestEndRequest object.
func (r ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest) AbTestEndRequestVNext(abTestEndRequestVNext AbTestEndRequestVNext) ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest {
	r.abTestEndRequestVNext = &abTestEndRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesAbTestEndEndActiveABTestExecute(r)
}

/*
PostCmsV3PagesSitePagesAbTestEndEndActiveABTest End an active A/B test

End an active A/B test and designate a winner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestEndEndActiveABTest(ctx context.Context) ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest {
	return ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestEndEndActiveABTestExecute(r ApiPostCmsV3PagesSitePagesAbTestEndEndActiveABTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesAbTestEndEndActiveABTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/ab-test/end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestEndRequestVNext == nil {
		return nil, reportError("abTestEndRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestEndRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	abTestRerunRequestVNext *AbTestRerunRequestVNext
}

// The JSON representation of the AbTestRerunRequest object.
func (r ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest) AbTestRerunRequestVNext(abTestRerunRequestVNext AbTestRerunRequestVNext) ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest {
	r.abTestRerunRequestVNext = &abTestRerunRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestExecute(r)
}

/*
PostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTest Rerun a previous A/B test

Rerun a previous A/B test.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTest(ctx context.Context) ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest {
	return ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestExecute(r ApiPostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesAbTestRerunRerunPreviousABTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/ab-test/rerun"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestRerunRequestVNext == nil {
		return nil, reportError("abTestRerunRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestRerunRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	batchInputString *BatchInputString
}

// The JSON array of Site Page ids.
func (r ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesBatchArchiveArchiveBatchExecute(r)
}

/*
PostCmsV3PagesSitePagesBatchArchiveArchiveBatch Delete a batch of Site Pages

Delete the Site Page objects identified in the request body.
Note: This is not the same as the dashboard `archive` function. To perform a dashboard `archive` send an normal update with the `archivedInDashboard` field set to true.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchArchiveArchiveBatch(ctx context.Context) ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest {
	return ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchArchiveArchiveBatchExecute(r ApiPostCmsV3PagesSitePagesBatchArchiveArchiveBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesBatchArchiveArchiveBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	batchInputPage *BatchInputPage
}

// The JSON array of new Site Pages to create.
func (r ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest) BatchInputPage(batchInputPage BatchInputPage) ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest {
	r.batchInputPage = &batchInputPage
	return r
}

func (r ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesBatchCreateCreateBatchExecute(r)
}

/*
PostCmsV3PagesSitePagesBatchCreateCreateBatch Create a batch of Site Pages

Create the Site Page objects detailed in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchCreateCreateBatch(ctx context.Context) ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest {
	return ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchCreateCreateBatchExecute(r ApiPostCmsV3PagesSitePagesBatchCreateCreateBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesBatchCreateCreateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPage == nil {
		return localVarReturnValue, nil, reportError("batchInputPage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	batchInputString *BatchInputString
	archived *bool
}

// The JSON array of Site Page ids.
func (r ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return deleted Site Pages. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest) Archived(archived bool) ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesBatchReadReadBatchExecute(r)
}

/*
PostCmsV3PagesSitePagesBatchReadReadBatch Retrieve a batch of Site Pages

Retrieve the Site Page objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchReadReadBatch(ctx context.Context) ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest {
	return ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchReadReadBatchExecute(r ApiPostCmsV3PagesSitePagesBatchReadReadBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesBatchReadReadBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	batchInputJsonNode *BatchInputJsonNode
	archived *bool
}

// The JSON representation of the updated Site Pages.
func (r ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Specifies whether to update deleted Site Pages. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest) Archived(archived bool) ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesBatchUpdateUpdateBatchExecute(r)
}

/*
PostCmsV3PagesSitePagesBatchUpdateUpdateBatch Update a batch of Site Pages

Update the Site Page objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchUpdateUpdateBatch(ctx context.Context) ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest {
	return ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesBatchUpdateUpdateBatchExecute(r ApiPostCmsV3PagesSitePagesBatchUpdateUpdateBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesBatchUpdateUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesCloneCloneRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	contentCloneRequestVNext *ContentCloneRequestVNext
}

// The JSON representation of the ContentCloneRequest object.
func (r ApiPostCmsV3PagesSitePagesCloneCloneRequest) ContentCloneRequestVNext(contentCloneRequestVNext ContentCloneRequestVNext) ApiPostCmsV3PagesSitePagesCloneCloneRequest {
	r.contentCloneRequestVNext = &contentCloneRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesCloneCloneRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesCloneCloneExecute(r)
}

/*
PostCmsV3PagesSitePagesCloneClone Clone a Site Page

Clone a Site Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesCloneCloneRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesCloneClone(ctx context.Context) ApiPostCmsV3PagesSitePagesCloneCloneRequest {
	return ApiPostCmsV3PagesSitePagesCloneCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesCloneCloneExecute(r ApiPostCmsV3PagesSitePagesCloneCloneRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesCloneClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("contentCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesCreateRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	page *Page
}

// The JSON representation of a new Site Page.
func (r ApiPostCmsV3PagesSitePagesCreateRequest) Page(page Page) ApiPostCmsV3PagesSitePagesCreateRequest {
	r.page = &page
	return r
}

func (r ApiPostCmsV3PagesSitePagesCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesCreateExecute(r)
}

/*
PostCmsV3PagesSitePagesCreate Create a new Site Page

Create a new Site Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesCreateRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesCreate(ctx context.Context) ApiPostCmsV3PagesSitePagesCreateRequest {
	return ApiPostCmsV3PagesSitePagesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesCreateExecute(r ApiPostCmsV3PagesSitePagesCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return nil, reportError("page is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	attachToLangPrimaryRequestVNext *AttachToLangPrimaryRequestVNext
}

// The JSON representation of the AttachToLangPrimaryRequest object.
func (r ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) AttachToLangPrimaryRequestVNext(attachToLangPrimaryRequestVNext AttachToLangPrimaryRequestVNext) ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	r.attachToLangPrimaryRequestVNext = &attachToLangPrimaryRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r)
}

/*
PostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroup Attach a site page to a multi-language group

Attach a site page to a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroup(ctx context.Context) ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	return ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r ApiPostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesMultiLanguageAttachToLangGroupAttachToLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/multi-language/attach-to-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachToLangPrimaryRequestVNext == nil {
		return nil, reportError("attachToLangPrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachToLangPrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	contentLanguageCloneRequestVNext *ContentLanguageCloneRequestVNext
}

// The JSON representation of the ContentLanguageCloneRequest object.
func (r ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) ContentLanguageCloneRequestVNext(contentLanguageCloneRequestVNext ContentLanguageCloneRequestVNext) ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	r.contentLanguageCloneRequestVNext = &contentLanguageCloneRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r)
}

/*
PostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariation Create a new language variation

Create a new language variation from an existing site page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariation(ctx context.Context) ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	return ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r ApiPostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesMultiLanguageCreateLanguageVariationCreateLangVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/multi-language/create-language-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentLanguageCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("contentLanguageCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentLanguageCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	detachFromLangGroupRequestVNext *DetachFromLangGroupRequestVNext
}

// The JSON representation of the DetachFromLangGroupRequest object.
func (r ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) DetachFromLangGroupRequestVNext(detachFromLangGroupRequestVNext DetachFromLangGroupRequestVNext) ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	r.detachFromLangGroupRequestVNext = &detachFromLangGroupRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r)
}

/*
PostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroup Detach a site page from a multi-language group

Detach a site page from a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroup(ctx context.Context) ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	return ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r ApiPostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesMultiLanguageDetachFromLangGroupDetachFromLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/multi-language/detach-from-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.detachFromLangGroupRequestVNext == nil {
		return nil, reportError("detachFromLangGroupRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.detachFromLangGroupRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	updateLanguagesRequestVNext *UpdateLanguagesRequestVNext
}

// The JSON representation of the UpdateLanguagesRequest object.
func (r ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest) UpdateLanguagesRequestVNext(updateLanguagesRequestVNext UpdateLanguagesRequestVNext) ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest {
	r.updateLanguagesRequestVNext = &updateLanguagesRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsExecute(r)
}

/*
PostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangs Update languages of multi-language group

Explicitly set new languages for each site page in a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangs(ctx context.Context) ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest {
	return ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsExecute(r ApiPostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesMultiLanguageUpdateLanguagesUpdateLangs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/multi-language/update-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLanguagesRequestVNext == nil {
		return nil, reportError("updateLanguagesRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLanguagesRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
}

func (r ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveExecute(r)
}

/*
PostCmsV3PagesSitePagesObjectIdDraftPushLivePushLive Push Site Page draft edits live

Take any changes from the draft version of the Site Page and apply them to the live version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Site Page for which it's draft will be pushed live.
 @return ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdDraftPushLivePushLive(ctx context.Context, objectId string) ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest {
	return ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveExecute(r ApiPostCmsV3PagesSitePagesObjectIdDraftPushLivePushLiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesObjectIdDraftPushLivePushLive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/draft/push-live"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
}

func (r ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesObjectIdDraftResetResetDraftExecute(r)
}

/*
PostCmsV3PagesSitePagesObjectIdDraftResetResetDraft Reset the Site Page draft to the live version

Discards any edits and resets the draft to the live version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Site Page for which it's draft will be reset.
 @return ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdDraftResetResetDraft(ctx context.Context, objectId string) ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest {
	return ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdDraftResetResetDraftExecute(r ApiPostCmsV3PagesSitePagesObjectIdDraftResetResetDraftRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesObjectIdDraftResetResetDraft")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/draft/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	revisionId string
}

func (r ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r)
}

/*
PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion Restore a previous version of a Site Page

Takes a specified version of a Site Page and restores it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @param revisionId The Site Page version id to restore.
 @return ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion(ctx context.Context, objectId string, revisionId string) ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest {
	return ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/revisions/{revisionId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	objectId string
	revisionId int64
}

func (r ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r)
}

/*
PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft Restore a previous version of a Site Page, to the draft version of the Site Page

Takes a specified version of a Site Page, sets it as the new draft version of the Site Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Site Page id.
 @param revisionId The Site Page version id to restore.
 @return ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft(ctx context.Context, objectId string, revisionId int64) ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest {
	return ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return Page
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r ApiPostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/{objectId}/revisions/{revisionId}/restore-to-draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesSitePagesScheduleScheduleRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	contentScheduleRequestVNext *ContentScheduleRequestVNext
}

// The JSON representation of the ContentScheduleRequestVNext object.
func (r ApiPostCmsV3PagesSitePagesScheduleScheduleRequest) ContentScheduleRequestVNext(contentScheduleRequestVNext ContentScheduleRequestVNext) ApiPostCmsV3PagesSitePagesScheduleScheduleRequest {
	r.contentScheduleRequestVNext = &contentScheduleRequestVNext
	return r
}

func (r ApiPostCmsV3PagesSitePagesScheduleScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesSitePagesScheduleScheduleExecute(r)
}

/*
PostCmsV3PagesSitePagesScheduleSchedule Schedule a Site Page to be Published

Schedule a Site Page to be Published

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesSitePagesScheduleScheduleRequest
*/
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesScheduleSchedule(ctx context.Context) ApiPostCmsV3PagesSitePagesScheduleScheduleRequest {
	return ApiPostCmsV3PagesSitePagesScheduleScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PostCmsV3PagesSitePagesScheduleScheduleExecute(r ApiPostCmsV3PagesSitePagesScheduleScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PostCmsV3PagesSitePagesScheduleSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentScheduleRequestVNext == nil {
		return nil, reportError("contentScheduleRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentScheduleRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest struct {
	ctx context.Context
	ApiService *SitePagesAPIService
	setNewLanguagePrimaryRequestVNext *SetNewLanguagePrimaryRequestVNext
}

// The JSON representation of the SetNewLanguagePrimaryRequest object.
func (r ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) SetNewLanguagePrimaryRequestVNext(setNewLanguagePrimaryRequestVNext SetNewLanguagePrimaryRequestVNext) ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	r.setNewLanguagePrimaryRequestVNext = &setNewLanguagePrimaryRequestVNext
	return r
}

func (r ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r)
}

/*
PutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimary Set a new primary language

Set a site page as the primary language of a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest
*/
func (a *SitePagesAPIService) PutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimary(ctx context.Context) ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	return ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SitePagesAPIService) PutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r ApiPutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitePagesAPIService.PutCmsV3PagesSitePagesMultiLanguageSetNewLangPrimarySetLangPrimary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/site-pages/multi-language/set-new-lang-primary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setNewLanguagePrimaryRequestVNext == nil {
		return nil, reportError("setNewLanguagePrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setNewLanguagePrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
