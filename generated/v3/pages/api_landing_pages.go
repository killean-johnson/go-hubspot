/*
Pages

Use these endpoints for interacting with Landing Pages and Site Pages

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pages

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/clarkmcc/go-hubspot"
"net/url"
	"strings"
	"time"
	"reflect"
)


// LandingPagesAPIService LandingPagesAPI service
type LandingPagesAPIService service

type ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	archived *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest) Archived(archived bool) ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderExecute(r)
}

/*
DeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolder Delete a Folder

Delete the Folder object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @return ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest
*/
func (a *LandingPagesAPIService) DeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolder(ctx context.Context, objectId string) ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest {
	return ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) DeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderExecute(r ApiDeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.DeleteCmsV3PagesLandingPagesFoldersObjectIdArchiveFolder")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	archived *bool
}

// Whether to return only results that have been archived.
func (r ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest) Archived(archived bool) ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest {
	r.archived = &archived
	return r
}

func (r ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCmsV3PagesLandingPagesObjectIdArchiveExecute(r)
}

/*
DeleteCmsV3PagesLandingPagesObjectIdArchive Delete a Landing Page

Delete the Landing Page object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest
*/
func (a *LandingPagesAPIService) DeleteCmsV3PagesLandingPagesObjectIdArchive(ctx context.Context, objectId string) ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest {
	return ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) DeleteCmsV3PagesLandingPagesObjectIdArchiveExecute(r ApiDeleteCmsV3PagesLandingPagesObjectIdArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.DeleteCmsV3PagesLandingPagesObjectIdArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	createdAt *time.Time
	createdAfter *time.Time
	createdBefore *time.Time
	updatedAt *time.Time
	updatedAfter *time.Time
	updatedBefore *time.Time
	sort *[]string
	after *string
	limit *int32
	archived *bool
	property *string
}

// Only return Folders created at exactly the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Folders created after the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Folders created before the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Folders last updated at exactly the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Folders last updated after the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Folders last updated before the specified time.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) Sort(sort []string) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) After(after string) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) Limit(limit int32) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return deleted Folders. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) Archived(archived bool) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) Property(property string) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) Execute() (*CollectionResponseWithTotalContentFolderForwardPaging, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesFoldersGetFoldersPageExecute(r)
}

/*
GetCmsV3PagesLandingPagesFoldersGetFoldersPage Get all Landing Page Folders

Get the list of Landing Page Folders. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersGetFoldersPage(ctx context.Context) ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest {
	return ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalContentFolderForwardPaging
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersGetFoldersPageExecute(r ApiGetCmsV3PagesLandingPagesFoldersGetFoldersPageRequest) (*CollectionResponseWithTotalContentFolderForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalContentFolderForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesFoldersGetFoldersPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "form", "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	archived *bool
	property *string
}

// Specifies whether to return deleted Folders. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest) Archived(archived bool) ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest) Property(property string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest) Execute() (*ContentFolder, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdExecute(r)
}

/*
GetCmsV3PagesLandingPagesFoldersObjectIdGetFolderById Retrieve a Folder

Retrieve the Folder object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @return ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdGetFolderById(ctx context.Context, objectId string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest {
	return ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return ContentFolder
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdExecute(r ApiGetCmsV3PagesLandingPagesFoldersObjectIdGetFolderByIdRequest) (*ContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesFoldersObjectIdGetFolderById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	after *string
	before *string
	limit *int32
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest) After(after string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest {
	r.after = &after
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest) Before(before string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest {
	r.before = &before
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest) Limit(limit int32) ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest) Execute() (*CollectionResponseWithTotalVersionContentFolder, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsExecute(r)
}

/*
GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersions Retrieves all the previous versions of a Folder

Retrieves all the previous versions of a Folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @return ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersions(ctx context.Context, objectId string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest {
	return ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalVersionContentFolder
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsExecute(r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersionsRequest) (*CollectionResponseWithTotalVersionContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalVersionContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsGetFolderPreviousVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	revisionId string
}

func (r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest) Execute() (*VersionContentFolder, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionExecute(r)
}

/*
GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersion Retrieves a previous version of a Folder

Retrieves a previous version of a Folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @param revisionId The Folder version id.
 @return ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersion(ctx context.Context, objectId string, revisionId string) ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest {
	return ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return VersionContentFolder
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionExecute(r ApiGetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersionRequest) (*VersionContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdGetFolderPreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}/revisions/{revisionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesGetPageRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	createdAt *time.Time
	createdAfter *time.Time
	createdBefore *time.Time
	updatedAt *time.Time
	updatedAfter *time.Time
	updatedBefore *time.Time
	sort *[]string
	after *string
	limit *int32
	archived *bool
	property *string
}

// Only return Landing Pages created at exactly the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) CreatedAt(createdAt time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.createdAt = &createdAt
	return r
}

// Only return Landing Pages created after the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) CreatedAfter(createdAfter time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.createdAfter = &createdAfter
	return r
}

// Only return Landing Pages created before the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) CreatedBefore(createdBefore time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.createdBefore = &createdBefore
	return r
}

// Only return Landing Pages last updated at exactly the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) UpdatedAt(updatedAt time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.updatedAt = &updatedAt
	return r
}

// Only return Landing Pages last updated after the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) UpdatedAfter(updatedAfter time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.updatedAfter = &updatedAfter
	return r
}

// Only return Landing Pages last updated before the specified time.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) UpdatedBefore(updatedBefore time.Time) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.updatedBefore = &updatedBefore
	return r
}

// Specifies which fields to use for sorting results. Valid fields are &#x60;name&#x60;, &#x60;createdAt&#x60;, &#x60;updatedAt&#x60;, &#x60;createdBy&#x60;, &#x60;updatedBy&#x60;. &#x60;createdAt&#x60; will be used by default.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) Sort(sort []string) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.sort = &sort
	return r
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) After(after string) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.after = &after
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) Limit(limit int32) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.limit = &limit
	return r
}

// Specifies whether to return deleted Landing Pages. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) Archived(archived bool) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) Property(property string) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesLandingPagesGetPageRequest) Execute() (*CollectionResponseWithTotalPageForwardPaging, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesGetPageExecute(r)
}

/*
GetCmsV3PagesLandingPagesGetPage Get all Landing Pages

Get the list of landing pages. Supports paging and filtering. This method would be useful for an integration that examined these models and used an external service to suggest edits.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetCmsV3PagesLandingPagesGetPageRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesGetPage(ctx context.Context) ApiGetCmsV3PagesLandingPagesGetPageRequest {
	return ApiGetCmsV3PagesLandingPagesGetPageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalPageForwardPaging
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesGetPageExecute(r ApiGetCmsV3PagesLandingPagesGetPageRequest) (*CollectionResponseWithTotalPageForwardPaging, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalPageForwardPaging
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesGetPage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAt", r.createdAt, "form", "")
	}
	if r.createdAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdAfter", r.createdAfter, "form", "")
	}
	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "form", "")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAt", r.updatedAt, "form", "")
	}
	if r.updatedAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedAfter", r.updatedAfter, "form", "")
	}
	if r.updatedBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updatedBefore", r.updatedBefore, "form", "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "form", "multi")
		}
	}
	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdExecute(r)
}

/*
GetCmsV3PagesLandingPagesObjectIdDraftGetDraftById Retrieve the full draft version of the Landing Page

Retrieve the full draft version of the Landing Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdDraftGetDraftById(ctx context.Context, objectId string) ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest {
	return ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdExecute(r ApiGetCmsV3PagesLandingPagesObjectIdDraftGetDraftByIdRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesObjectIdDraftGetDraftById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	archived *bool
	property *string
}

// Specifies whether to return deleted Landing Pages. Defaults to &#x60;false&#x60;.
func (r ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest) Archived(archived bool) ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest {
	r.archived = &archived
	return r
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest) Property(property string) ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest {
	r.property = &property
	return r
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesObjectIdGetByIdExecute(r)
}

/*
GetCmsV3PagesLandingPagesObjectIdGetById Retrieve a Landing Page

Retrieve the Landing Page object identified by the id in the path.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdGetById(ctx context.Context, objectId string) ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest {
	return ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdGetByIdExecute(r ApiGetCmsV3PagesLandingPagesObjectIdGetByIdRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesObjectIdGetById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	if r.property != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "property", r.property, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	after *string
	before *string
	limit *int32
}

// The cursor token value to get the next set of results. You can get this from the &#x60;paging.next.after&#x60; JSON property of a paged response containing more results.
func (r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest) After(after string) ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.after = &after
	return r
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest) Before(before string) ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.before = &before
	return r
}

// The maximum number of results to return. Default is 100.
func (r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest) Limit(limit int32) ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest) Execute() (*CollectionResponseWithTotalVersionPage, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsExecute(r)
}

/*
GetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersions Retrieves all the previous versions of a Landing Page

Retrieves all the previous versions of a Landing Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersions(ctx context.Context, objectId string) ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest {
	return ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return CollectionResponseWithTotalVersionPage
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsExecute(r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersionsRequest) (*CollectionResponseWithTotalVersionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionResponseWithTotalVersionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesObjectIdRevisionsGetPreviousVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/revisions"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	revisionId string
}

func (r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest) Execute() (*VersionPage, *http.Response, error) {
	return r.ApiService.GetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r)
}

/*
GetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersion Retrieves a previous version of a Landing Page

Retrieves a previous version of a Landing Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @param revisionId The Landing Page version id.
 @return ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest
*/
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersion(ctx context.Context, objectId string, revisionId string) ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest {
	return ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return VersionPage
func (a *LandingPagesAPIService) GetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionExecute(r ApiGetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersionRequest) (*VersionPage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VersionPage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.GetCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdGetPreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/revisions/{revisionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	contentFolder *ContentFolder
	archived *bool
}

// The JSON representation of the updated Folder.
func (r ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest) ContentFolder(contentFolder ContentFolder) ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest {
	r.contentFolder = &contentFolder
	return r
}

// Specifies whether to update deleted Folders. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest) Archived(archived bool) ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest) Execute() (*ContentFolder, *http.Response, error) {
	return r.ApiService.PatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderExecute(r)
}

/*
PatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolder Update a Folder

Sparse updates a single Folder object identified by the id in the path.
You only need to specify the column values that you are modifying.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @return ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest
*/
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolder(ctx context.Context, objectId string) ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest {
	return ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return ContentFolder
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderExecute(r ApiPatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolderRequest) (*ContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PatchCmsV3PagesLandingPagesFoldersObjectIdUpdateFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentFolder == nil {
		return localVarReturnValue, nil, reportError("contentFolder is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentFolder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	page *Page
}

// The JSON representation of the updated Landing Page to be applied to the draft.
func (r ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest) Page(page Page) ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest {
	r.page = &page
	return r
}

func (r ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftExecute(r)
}

/*
PatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraft Update a Landing Page draft

Sparse updates the draft version of a single Landing Page object identified by the id in the path.
You only need to specify the column values that you are modifying.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest
*/
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraft(ctx context.Context, objectId string) ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest {
	return ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftExecute(r ApiPatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraftRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PatchCmsV3PagesLandingPagesObjectIdDraftUpdateDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	page *Page
	archived *bool
}

// The JSON representation of the updated Landing Page.
func (r ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest) Page(page Page) ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest {
	r.page = &page
	return r
}

// Specifies whether to update deleted Landing Pages. Defaults to &#x60;false&#x60;.
func (r ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest) Archived(archived bool) ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest {
	r.archived = &archived
	return r
}

func (r ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PatchCmsV3PagesLandingPagesObjectIdUpdateExecute(r)
}

/*
PatchCmsV3PagesLandingPagesObjectIdUpdate Update a Landing Page

Sparse updates a single Landing Page object identified by the id in the path.
You only need to specify the column values that you are modifying.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @return ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest
*/
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesObjectIdUpdate(ctx context.Context, objectId string) ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest {
	return ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PatchCmsV3PagesLandingPagesObjectIdUpdateExecute(r ApiPatchCmsV3PagesLandingPagesObjectIdUpdateRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PatchCmsV3PagesLandingPagesObjectIdUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return localVarReturnValue, nil, reportError("page is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	abTestCreateRequestVNext *AbTestCreateRequestVNext
}

// The JSON representation of the AbTestCreateRequest object.
func (r ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest) AbTestCreateRequestVNext(abTestCreateRequestVNext AbTestCreateRequestVNext) ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest {
	r.abTestCreateRequestVNext = &abTestCreateRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationExecute(r)
}

/*
PostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariation Create a new A/B test variation

Create a new A/B test variation based on the information provided in the request body.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariation(ctx context.Context) ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest {
	return ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationExecute(r ApiPostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariationRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesAbTestCreateVariationCreateABTestVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/ab-test/create-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestCreateRequestVNext == nil {
		return localVarReturnValue, nil, reportError("abTestCreateRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestCreateRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	abTestEndRequestVNext *AbTestEndRequestVNext
}

// The JSON representation of the AbTestEndRequest object.
func (r ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest) AbTestEndRequestVNext(abTestEndRequestVNext AbTestEndRequestVNext) ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest {
	r.abTestEndRequestVNext = &abTestEndRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesAbTestEndEndActiveABTestExecute(r)
}

/*
PostCmsV3PagesLandingPagesAbTestEndEndActiveABTest End an active A/B test

End an active A/B test and designate a winner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestEndEndActiveABTest(ctx context.Context) ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest {
	return ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestEndEndActiveABTestExecute(r ApiPostCmsV3PagesLandingPagesAbTestEndEndActiveABTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesAbTestEndEndActiveABTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/ab-test/end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestEndRequestVNext == nil {
		return nil, reportError("abTestEndRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestEndRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	abTestRerunRequestVNext *AbTestRerunRequestVNext
}

// The JSON representation of the AbTestRerunRequest object.
func (r ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest) AbTestRerunRequestVNext(abTestRerunRequestVNext AbTestRerunRequestVNext) ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest {
	r.abTestRerunRequestVNext = &abTestRerunRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestExecute(r)
}

/*
PostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTest Rerun a previous A/B test

Rerun a previous A/B test.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTest(ctx context.Context) ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest {
	return ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestExecute(r ApiPostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTestRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesAbTestRerunRerunPreviousABTest")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/ab-test/rerun"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.abTestRerunRequestVNext == nil {
		return nil, reportError("abTestRerunRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.abTestRerunRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputString *BatchInputString
}

// The JSON array of Landing Page ids.
func (r ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesBatchArchiveArchiveBatchExecute(r)
}

/*
PostCmsV3PagesLandingPagesBatchArchiveArchiveBatch Delete a batch of Landing Pages

Delete the Landing Page objects identified in the request body.
Note: This is not the same as the dashboard `archive` function. To perform a dashboard `archive` send an normal update with the `archivedInDashboard` field set to true.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchArchiveArchiveBatch(ctx context.Context) ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest {
	return ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchArchiveArchiveBatchExecute(r ApiPostCmsV3PagesLandingPagesBatchArchiveArchiveBatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesBatchArchiveArchiveBatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputPage *BatchInputPage
}

// The JSON array of new Landing Pages to create.
func (r ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest) BatchInputPage(batchInputPage BatchInputPage) ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest {
	r.batchInputPage = &batchInputPage
	return r
}

func (r ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesBatchCreateCreateBatchExecute(r)
}

/*
PostCmsV3PagesLandingPagesBatchCreateCreateBatch Create a batch of Landing Pages

Create the Landing Page objects detailed in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchCreateCreateBatch(ctx context.Context) ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest {
	return ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchCreateCreateBatchExecute(r ApiPostCmsV3PagesLandingPagesBatchCreateCreateBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesBatchCreateCreateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPage == nil {
		return localVarReturnValue, nil, reportError("batchInputPage is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputString *BatchInputString
	archived *bool
}

// The JSON array of Landing Page ids.
func (r ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return deleted Landing Pages. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest) Archived(archived bool) ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesBatchReadReadBatchExecute(r)
}

/*
PostCmsV3PagesLandingPagesBatchReadReadBatch Retrieve a batch of Landing Pages

Retrieve the Landing Page objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchReadReadBatch(ctx context.Context) ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest {
	return ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchReadReadBatchExecute(r ApiPostCmsV3PagesLandingPagesBatchReadReadBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesBatchReadReadBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputJsonNode *BatchInputJsonNode
	archived *bool
}

// The JSON representation of the updated Landing Pages.
func (r ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Specifies whether to update deleted Landing Pages. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest) Archived(archived bool) ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest) Execute() (*BatchResponsePage, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesBatchUpdateUpdateBatchExecute(r)
}

/*
PostCmsV3PagesLandingPagesBatchUpdateUpdateBatch Update a batch of Landing Pages

Update the Landing Page objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchUpdateUpdateBatch(ctx context.Context) ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest {
	return ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePage
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesBatchUpdateUpdateBatchExecute(r ApiPostCmsV3PagesLandingPagesBatchUpdateUpdateBatchRequest) (*BatchResponsePage, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePage
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesBatchUpdateUpdateBatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesCloneCloneRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	contentCloneRequestVNext *ContentCloneRequestVNext
}

// The JSON representation of the ContentCloneRequest object.
func (r ApiPostCmsV3PagesLandingPagesCloneCloneRequest) ContentCloneRequestVNext(contentCloneRequestVNext ContentCloneRequestVNext) ApiPostCmsV3PagesLandingPagesCloneCloneRequest {
	r.contentCloneRequestVNext = &contentCloneRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesCloneCloneRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesCloneCloneExecute(r)
}

/*
PostCmsV3PagesLandingPagesCloneClone Clone a Landing Page

Clone a Landing Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesCloneCloneRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesCloneClone(ctx context.Context) ApiPostCmsV3PagesLandingPagesCloneCloneRequest {
	return ApiPostCmsV3PagesLandingPagesCloneCloneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesCloneCloneExecute(r ApiPostCmsV3PagesLandingPagesCloneCloneRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesCloneClone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/clone"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("contentCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesCreateRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	page *Page
}

// The JSON representation of a new Landing Page.
func (r ApiPostCmsV3PagesLandingPagesCreateRequest) Page(page Page) ApiPostCmsV3PagesLandingPagesCreateRequest {
	r.page = &page
	return r
}

func (r ApiPostCmsV3PagesLandingPagesCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesCreateExecute(r)
}

/*
PostCmsV3PagesLandingPagesCreate Create a new Landing Page

Create a new Landing Page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesCreateRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesCreate(ctx context.Context) ApiPostCmsV3PagesLandingPagesCreateRequest {
	return ApiPostCmsV3PagesLandingPagesCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesCreateExecute(r ApiPostCmsV3PagesLandingPagesCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.page == nil {
		return nil, reportError("page is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.page
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputString *BatchInputString
}

// The JSON array of Folder ids.
func (r ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest {
	r.batchInputString = &batchInputString
	return r
}

func (r ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFolders Delete a batch of Folders

Delete the Folder objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFolders(ctx context.Context) ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersExecute(r ApiPostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFoldersRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersBatchArchiveArchiveFolders")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return nil, reportError("batchInputString is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputContentFolder *BatchInputContentFolder
}

// The JSON array of new Folders to create.
func (r ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest) BatchInputContentFolder(batchInputContentFolder BatchInputContentFolder) ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest {
	r.batchInputContentFolder = &batchInputContentFolder
	return r
}

func (r ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest) Execute() (*BatchResponseContentFolder, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersBatchCreateCreateFolders Create a batch of Folders

Create the Folder objects detailed in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchCreateCreateFolders(ctx context.Context) ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponseContentFolder
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersExecute(r ApiPostCmsV3PagesLandingPagesFoldersBatchCreateCreateFoldersRequest) (*BatchResponseContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponseContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersBatchCreateCreateFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputContentFolder == nil {
		return localVarReturnValue, nil, reportError("batchInputContentFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputContentFolder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputString *BatchInputString
	archived *bool
}

// The JSON array of Folder ids.
func (r ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest) BatchInputString(batchInputString BatchInputString) ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest {
	r.batchInputString = &batchInputString
	return r
}

// Specifies whether to return deleted Folders. Defaults to &#x60;false&#x60;.
func (r ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest) Archived(archived bool) ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest) Execute() (*BatchResponseContentFolder, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersBatchReadReadFolders Retrieve a batch of Folders

Update the Folder objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchReadReadFolders(ctx context.Context) ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponseContentFolder
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersExecute(r ApiPostCmsV3PagesLandingPagesFoldersBatchReadReadFoldersRequest) (*BatchResponseContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponseContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersBatchReadReadFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputString == nil {
		return localVarReturnValue, nil, reportError("batchInputString is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputString
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	batchInputJsonNode *BatchInputJsonNode
	archived *bool
}

func (r ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest) BatchInputJsonNode(batchInputJsonNode BatchInputJsonNode) ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest {
	r.batchInputJsonNode = &batchInputJsonNode
	return r
}

// Whether to return only results that have been archived.
func (r ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest) Archived(archived bool) ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest {
	r.archived = &archived
	return r
}

func (r ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest) Execute() (*BatchResponseContentFolder, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFolders Update a batch of Folders

Update the Folder objects identified in the request body.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFolders(ctx context.Context) ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponseContentFolder
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersExecute(r ApiPostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFoldersRequest) (*BatchResponseContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponseContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersBatchUpdateUpdateFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputJsonNode == nil {
		return localVarReturnValue, nil, reportError("batchInputJsonNode is required and must be specified")
	}

	if r.archived != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "archived", r.archived, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputJsonNode
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	contentFolder *ContentFolder
}

// The JSON representation of a new Folder.
func (r ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest) ContentFolder(contentFolder ContentFolder) ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest {
	r.contentFolder = &contentFolder
	return r
}

func (r ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest) Execute() (*ContentFolder, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersCreateFolderExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersCreateFolder Create a new Folder

Create a new Folder

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersCreateFolder(ctx context.Context) ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContentFolder
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersCreateFolderExecute(r ApiPostCmsV3PagesLandingPagesFoldersCreateFolderRequest) (*ContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersCreateFolder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentFolder == nil {
		return localVarReturnValue, nil, reportError("contentFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentFolder
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	revisionId string
}

func (r ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest) Execute() (*ContentFolder, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionExecute(r)
}

/*
PostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersion Restore a previous version of a Folder

Takes a specified version of a Folder and restores it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Folder id.
 @param revisionId The Folder version id to restore.
 @return ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersion(ctx context.Context, objectId string, revisionId string) ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest {
	return ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return ContentFolder
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionExecute(r ApiPostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersionRequest) (*ContentFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ContentFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesFoldersObjectIdRevisionsRevisionIdRestoreRestoreFolderPreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/folders/{objectId}/revisions/{revisionId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	attachToLangPrimaryRequestVNext *AttachToLangPrimaryRequestVNext
}

// The JSON representation of the AttachToLangPrimaryRequest object.
func (r ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) AttachToLangPrimaryRequestVNext(attachToLangPrimaryRequestVNext AttachToLangPrimaryRequestVNext) ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	r.attachToLangPrimaryRequestVNext = &attachToLangPrimaryRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r)
}

/*
PostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroup Attach a landing page to a multi-language group

Attach a landing page to a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroup(ctx context.Context) ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest {
	return ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupExecute(r ApiPostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesMultiLanguageAttachToLangGroupAttachToLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/multi-language/attach-to-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.attachToLangPrimaryRequestVNext == nil {
		return nil, reportError("attachToLangPrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attachToLangPrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	contentLanguageCloneRequestVNext *ContentLanguageCloneRequestVNext
}

// The JSON representation of the ContentLanguageCloneRequest object.
func (r ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) ContentLanguageCloneRequestVNext(contentLanguageCloneRequestVNext ContentLanguageCloneRequestVNext) ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	r.contentLanguageCloneRequestVNext = &contentLanguageCloneRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r)
}

/*
PostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariation Create a new language variation

Create a new language variation from an existing landing page

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariation(ctx context.Context) ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest {
	return ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationExecute(r ApiPostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariationRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesMultiLanguageCreateLanguageVariationCreateLangVariation")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/multi-language/create-language-variation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentLanguageCloneRequestVNext == nil {
		return localVarReturnValue, nil, reportError("contentLanguageCloneRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentLanguageCloneRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	detachFromLangGroupRequestVNext *DetachFromLangGroupRequestVNext
}

// The JSON representation of the DetachFromLangGroupRequest object.
func (r ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) DetachFromLangGroupRequestVNext(detachFromLangGroupRequestVNext DetachFromLangGroupRequestVNext) ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	r.detachFromLangGroupRequestVNext = &detachFromLangGroupRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r)
}

/*
PostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroup Detach a landing page from a multi-language group

Detach a landing page from a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroup(ctx context.Context) ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest {
	return ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupExecute(r ApiPostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesMultiLanguageDetachFromLangGroupDetachFromLangGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/multi-language/detach-from-lang-group"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.detachFromLangGroupRequestVNext == nil {
		return nil, reportError("detachFromLangGroupRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.detachFromLangGroupRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	updateLanguagesRequestVNext *UpdateLanguagesRequestVNext
}

// The JSON representation of the UpdateLanguagesRequest object.
func (r ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest) UpdateLanguagesRequestVNext(updateLanguagesRequestVNext UpdateLanguagesRequestVNext) ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest {
	r.updateLanguagesRequestVNext = &updateLanguagesRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsExecute(r)
}

/*
PostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangs Update languages of multi-language group

Explicitly set new languages for each landing page in a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangs(ctx context.Context) ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest {
	return ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsExecute(r ApiPostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesMultiLanguageUpdateLanguagesUpdateLangs")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/multi-language/update-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateLanguagesRequestVNext == nil {
		return nil, reportError("updateLanguagesRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateLanguagesRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
}

func (r ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveExecute(r)
}

/*
PostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLive Push Landing Page draft edits live

Take any changes from the draft version of the Landing Page and apply them to the live version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Landing Page for which it's draft will be pushed live.
 @return ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLive(ctx context.Context, objectId string) ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest {
	return ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveExecute(r ApiPostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesObjectIdDraftPushLivePushLive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/draft/push-live"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
}

func (r ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftExecute(r)
}

/*
PostCmsV3PagesLandingPagesObjectIdDraftResetResetDraft Reset the Landing Page draft to the live version

Discards any edits and resets the draft to the live version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The id of the Landing Page for which it's draft will be reset.
 @return ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdDraftResetResetDraft(ctx context.Context, objectId string) ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest {
	return ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftExecute(r ApiPostCmsV3PagesLandingPagesObjectIdDraftResetResetDraftRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesObjectIdDraftResetResetDraft")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/draft/reset"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	revisionId string
}

func (r ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r)
}

/*
PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion Restore a previous version of a Landing Page

Takes a specified version of a Landing Page and restores it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @param revisionId The Landing Page version id to restore.
 @return ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion(ctx context.Context, objectId string, revisionId string) ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest {
	return ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionExecute(r ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersionRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreRestorePreviousVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/revisions/{revisionId}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	objectId string
	revisionId int64
}

func (r ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) Execute() (*Page, *http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r)
}

/*
PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft Restore a previous version of a Landing Page, to the draft version of the Landing Page

Takes a specified version of a Landing Page, sets it as the new draft version of the Landing Page.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The Landing Page id.
 @param revisionId The Landing Page version id to restore.
 @return ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft(ctx context.Context, objectId string, revisionId int64) ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest {
	return ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
		revisionId: revisionId,
	}
}

// Execute executes the request
//  @return Page
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftExecute(r ApiPostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraftRequest) (*Page, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Page
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesObjectIdRevisionsRevisionIdRestoreToDraftRestorePreviousVersionToDraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/{objectId}/revisions/{revisionId}/restore-to-draft"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"revisionId"+"}", url.PathEscape(parameterValueToString(r.revisionId, "revisionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	contentScheduleRequestVNext *ContentScheduleRequestVNext
}

// The JSON representation of the ContentScheduleRequestVNext object.
func (r ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest) ContentScheduleRequestVNext(contentScheduleRequestVNext ContentScheduleRequestVNext) ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest {
	r.contentScheduleRequestVNext = &contentScheduleRequestVNext
	return r
}

func (r ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCmsV3PagesLandingPagesScheduleScheduleExecute(r)
}

/*
PostCmsV3PagesLandingPagesScheduleSchedule Schedule a Landing Page to be Published

Schedule a Landing Page to be Published

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest
*/
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesScheduleSchedule(ctx context.Context) ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest {
	return ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PostCmsV3PagesLandingPagesScheduleScheduleExecute(r ApiPostCmsV3PagesLandingPagesScheduleScheduleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PostCmsV3PagesLandingPagesScheduleSchedule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/schedule"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.contentScheduleRequestVNext == nil {
		return nil, reportError("contentScheduleRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contentScheduleRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest struct {
	ctx context.Context
	ApiService *LandingPagesAPIService
	setNewLanguagePrimaryRequestVNext *SetNewLanguagePrimaryRequestVNext
}

// The JSON representation of the SetNewLanguagePrimaryRequest object.
func (r ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) SetNewLanguagePrimaryRequestVNext(setNewLanguagePrimaryRequestVNext SetNewLanguagePrimaryRequestVNext) ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	r.setNewLanguagePrimaryRequestVNext = &setNewLanguagePrimaryRequestVNext
	return r
}

func (r ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) Execute() (*http.Response, error) {
	return r.ApiService.PutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r)
}

/*
PutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimary Set a new primary language

Set a landing page as the primary language of a multi-language group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest
*/
func (a *LandingPagesAPIService) PutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimary(ctx context.Context) ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest {
	return ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LandingPagesAPIService) PutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryExecute(r ApiPutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimaryRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LandingPagesAPIService.PutCmsV3PagesLandingPagesMultiLanguageSetNewLangPrimarySetLangPrimary")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cms/v3/pages/landing-pages/multi-language/set-new-lang-primary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setNewLanguagePrimaryRequestVNext == nil {
		return nil, reportError("setNewLanguagePrimaryRequestVNext is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setNewLanguagePrimaryRequestVNext
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
