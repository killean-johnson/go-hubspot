/*
CRM Exports

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package exports

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/clarkmcc/go-hubspot"
"net/url"
	"strings"
)


// PublicExportsAPIService PublicExportsAPI service
type PublicExportsAPIService service

type ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest struct {
	ctx context.Context
	ApiService *PublicExportsAPIService
	taskId int64
}

func (r ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest) Execute() (*ActionResponseWithSingleResultURI, *http.Response, error) {
	return r.ApiService.GetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusExecute(r)
}

/*
GetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatus Get the status of the export including the URL to download the file

Returns the status of the export with taskId, including the URL of the resulting file if the export status is COMPLETE

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param taskId
 @return ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest
*/
func (a *PublicExportsAPIService) GetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatus(ctx context.Context, taskId int64) ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest {
	return ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest{
		ApiService: a,
		ctx: ctx,
		taskId: taskId,
	}
}

// Execute executes the request
//  @return ActionResponseWithSingleResultURI
func (a *PublicExportsAPIService) GetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusExecute(r ApiGetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatusRequest) (*ActionResponseWithSingleResultURI, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActionResponseWithSingleResultURI
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicExportsAPIService.GetCrmV3ExportsExportAsyncTasksTaskIdStatusGetStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/exports/export/async/tasks/{taskId}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostCrmV3ExportsExportAsyncStartRequest struct {
	ctx context.Context
	ApiService *PublicExportsAPIService
	publicExportRequest *PublicExportRequest
}

func (r ApiPostCrmV3ExportsExportAsyncStartRequest) PublicExportRequest(publicExportRequest PublicExportRequest) ApiPostCrmV3ExportsExportAsyncStartRequest {
	r.publicExportRequest = &publicExportRequest
	return r
}

func (r ApiPostCrmV3ExportsExportAsyncStartRequest) Execute() (*TaskLocator, *http.Response, error) {
	return r.ApiService.PostCrmV3ExportsExportAsyncStartExecute(r)
}

/*
PostCrmV3ExportsExportAsyncStart Start an export

Begins exporting CRM data for the portal as specified in the request body

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCrmV3ExportsExportAsyncStartRequest
*/
func (a *PublicExportsAPIService) PostCrmV3ExportsExportAsyncStart(ctx context.Context) ApiPostCrmV3ExportsExportAsyncStartRequest {
	return ApiPostCrmV3ExportsExportAsyncStartRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TaskLocator
func (a *PublicExportsAPIService) PostCrmV3ExportsExportAsyncStartExecute(r ApiPostCrmV3ExportsExportAsyncStartRequest) (*TaskLocator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaskLocator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PublicExportsAPIService.PostCrmV3ExportsExportAsyncStart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/crm/v3/exports/export/async"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.publicExportRequest == nil {
		return localVarReturnValue, nil, reportError("publicExportRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publicExportRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
