/*
Campaigns Public Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package campaigns_public_api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/killean-johnson/go-hubspot"
"net/url"
	"strings"
)


// BudgetAPIService BudgetAPI service
type BudgetAPIService service

type ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest struct {
	ctx context.Context
	ApiService *BudgetAPIService
	campaignGuid string
}

func (r ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest) Execute() (*PublicBudgetTotals, *http.Response, error) {
	return r.ApiService.GetMarketingV3CampaignsCampaignGuidBudgetTotalsExecute(r)
}

/*
GetMarketingV3CampaignsCampaignGuidBudgetTotals Read budget

Retrieve detailed information about the budget and spend items for a specified campaign, including the total budget, total spend, and remaining budget.
Budget and Spend items may be returned in any order, but the order field specifies their sequence based on the creation date. The item with order 0 is the oldest, and items with higher order values are newer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param campaignGuid Unique identifier for the campaign, formatted as a UUID.
 @return ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest
*/
func (a *BudgetAPIService) GetMarketingV3CampaignsCampaignGuidBudgetTotals(ctx context.Context, campaignGuid string) ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest {
	return ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest{
		ApiService: a,
		ctx: ctx,
		campaignGuid: campaignGuid,
	}
}

// Execute executes the request
//  @return PublicBudgetTotals
func (a *BudgetAPIService) GetMarketingV3CampaignsCampaignGuidBudgetTotalsExecute(r ApiGetMarketingV3CampaignsCampaignGuidBudgetTotalsRequest) (*PublicBudgetTotals, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PublicBudgetTotals
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BudgetAPIService.GetMarketingV3CampaignsCampaignGuidBudgetTotals")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketing/v3/campaigns/{campaignGuid}/budget/totals"
	localVarPath = strings.Replace(localVarPath, "{"+"campaignGuid"+"}", url.PathEscape(parameterValueToString(r.campaignGuid, "campaignGuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
