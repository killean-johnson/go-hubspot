/*
Campaigns Public Api

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package campaigns_public_api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	
	"github.com/clarkmcc/go-hubspot"
"net/url"
	"reflect"
)


// BatchAPIService BatchAPI service
type BatchAPIService service

type ApiPostMarketingV3CampaignsBatchArchiveRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchInputPublicCampaignDeleteInput *BatchInputPublicCampaignDeleteInput
}

func (r ApiPostMarketingV3CampaignsBatchArchiveRequest) BatchInputPublicCampaignDeleteInput(batchInputPublicCampaignDeleteInput BatchInputPublicCampaignDeleteInput) ApiPostMarketingV3CampaignsBatchArchiveRequest {
	r.batchInputPublicCampaignDeleteInput = &batchInputPublicCampaignDeleteInput
	return r
}

func (r ApiPostMarketingV3CampaignsBatchArchiveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostMarketingV3CampaignsBatchArchiveExecute(r)
}

/*
PostMarketingV3CampaignsBatchArchive Delete a batch of campaigns

This endpoint deletes a batch of campaigns. 
The maximum number of items in a batch request is 50.
The response will always be 204 No Content, regardless of whether the campaigns exist or not, whether they were successfully deleted or not, or if only some of the campaigns in the batch were deleted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostMarketingV3CampaignsBatchArchiveRequest
*/
func (a *BatchAPIService) PostMarketingV3CampaignsBatchArchive(ctx context.Context) ApiPostMarketingV3CampaignsBatchArchiveRequest {
	return ApiPostMarketingV3CampaignsBatchArchiveRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BatchAPIService) PostMarketingV3CampaignsBatchArchiveExecute(r ApiPostMarketingV3CampaignsBatchArchiveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.PostMarketingV3CampaignsBatchArchive")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketing/v3/campaigns/batch/archive"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPublicCampaignDeleteInput == nil {
		return nil, reportError("batchInputPublicCampaignDeleteInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPublicCampaignDeleteInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostMarketingV3CampaignsBatchCreateRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchInputPublicCampaignInput *BatchInputPublicCampaignInput
}

func (r ApiPostMarketingV3CampaignsBatchCreateRequest) BatchInputPublicCampaignInput(batchInputPublicCampaignInput BatchInputPublicCampaignInput) ApiPostMarketingV3CampaignsBatchCreateRequest {
	r.batchInputPublicCampaignInput = &batchInputPublicCampaignInput
	return r
}

func (r ApiPostMarketingV3CampaignsBatchCreateRequest) Execute() (*BatchResponsePublicCampaign, *http.Response, error) {
	return r.ApiService.PostMarketingV3CampaignsBatchCreateExecute(r)
}

/*
PostMarketingV3CampaignsBatchCreate Create a batch of campaigns

This endpoint creates a batch of campaigns. The maximum number of items in a batch request is 50.
The campaigns in the response are not guaranteed to be in the same order as they were provided in the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostMarketingV3CampaignsBatchCreateRequest
*/
func (a *BatchAPIService) PostMarketingV3CampaignsBatchCreate(ctx context.Context) ApiPostMarketingV3CampaignsBatchCreateRequest {
	return ApiPostMarketingV3CampaignsBatchCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicCampaign
func (a *BatchAPIService) PostMarketingV3CampaignsBatchCreateExecute(r ApiPostMarketingV3CampaignsBatchCreateRequest) (*BatchResponsePublicCampaign, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicCampaign
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.PostMarketingV3CampaignsBatchCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketing/v3/campaigns/batch/create"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPublicCampaignInput == nil {
		return localVarReturnValue, nil, reportError("batchInputPublicCampaignInput is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPublicCampaignInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostMarketingV3CampaignsBatchReadRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchInputPublicCampaignReadInput *BatchInputPublicCampaignReadInput
	startDate *string
	endDate *string
	properties *[]string
}

func (r ApiPostMarketingV3CampaignsBatchReadRequest) BatchInputPublicCampaignReadInput(batchInputPublicCampaignReadInput BatchInputPublicCampaignReadInput) ApiPostMarketingV3CampaignsBatchReadRequest {
	r.batchInputPublicCampaignReadInput = &batchInputPublicCampaignReadInput
	return r
}

// Start date to fetch asset metrics, formatted as YYYY-MM-DD. This date is used to fetch the metrics associated with the assets for a specified period. If not provided, no asset metrics will be fetched. 
func (r ApiPostMarketingV3CampaignsBatchReadRequest) StartDate(startDate string) ApiPostMarketingV3CampaignsBatchReadRequest {
	r.startDate = &startDate
	return r
}

// End date to fetch asset metrics, formatted as YYYY-MM-DD. This date is used to fetch the metrics associated with the assets for a specified period. If not provided, no asset metrics will be fetched.
func (r ApiPostMarketingV3CampaignsBatchReadRequest) EndDate(endDate string) ApiPostMarketingV3CampaignsBatchReadRequest {
	r.endDate = &endDate
	return r
}

// A comma-separated list of the properties to be returned in the response. If any of the specified properties has empty value on the requested object(s), they will be ignored and not returned in response. If this parameter is empty, the response will include an empty properties map.
func (r ApiPostMarketingV3CampaignsBatchReadRequest) Properties(properties []string) ApiPostMarketingV3CampaignsBatchReadRequest {
	r.properties = &properties
	return r
}

func (r ApiPostMarketingV3CampaignsBatchReadRequest) Execute() (*BatchResponsePublicCampaignWithAssets, *http.Response, error) {
	return r.ApiService.PostMarketingV3CampaignsBatchReadExecute(r)
}

/*
PostMarketingV3CampaignsBatchRead Read a batch of campaigns

This endpoint reads a batch of campaigns based on the provided input data and returns the campaigns along with their associated assets. 
The maximum number of items in a batch request is 50.
The campaigns in the response are not guaranteed to be in the same order as they were provided in the request.
If duplicate campaign IDs are provided in the request, duplicates will be ignored. The response will include only unique IDs and will be returned without duplicates.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostMarketingV3CampaignsBatchReadRequest
*/
func (a *BatchAPIService) PostMarketingV3CampaignsBatchRead(ctx context.Context) ApiPostMarketingV3CampaignsBatchReadRequest {
	return ApiPostMarketingV3CampaignsBatchReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicCampaignWithAssets
func (a *BatchAPIService) PostMarketingV3CampaignsBatchReadExecute(r ApiPostMarketingV3CampaignsBatchReadRequest) (*BatchResponsePublicCampaignWithAssets, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicCampaignWithAssets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.PostMarketingV3CampaignsBatchRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketing/v3/campaigns/batch/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPublicCampaignReadInput == nil {
		return localVarReturnValue, nil, reportError("batchInputPublicCampaignReadInput is required and must be specified")
	}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPublicCampaignReadInput
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostMarketingV3CampaignsBatchUpdateRequest struct {
	ctx context.Context
	ApiService *BatchAPIService
	batchInputPublicCampaignBatchUpdateItem *BatchInputPublicCampaignBatchUpdateItem
}

func (r ApiPostMarketingV3CampaignsBatchUpdateRequest) BatchInputPublicCampaignBatchUpdateItem(batchInputPublicCampaignBatchUpdateItem BatchInputPublicCampaignBatchUpdateItem) ApiPostMarketingV3CampaignsBatchUpdateRequest {
	r.batchInputPublicCampaignBatchUpdateItem = &batchInputPublicCampaignBatchUpdateItem
	return r
}

func (r ApiPostMarketingV3CampaignsBatchUpdateRequest) Execute() (*BatchResponsePublicCampaign, *http.Response, error) {
	return r.ApiService.PostMarketingV3CampaignsBatchUpdateExecute(r)
}

/*
PostMarketingV3CampaignsBatchUpdate Update a batch of campaigns

This endpoint updates a batch of campaigns based on the provided input data.
The maximum number of items in a batch request is 50.
If an empty string ("") is passed for any property in the Batch Update, it will reset that property's value.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostMarketingV3CampaignsBatchUpdateRequest
*/
func (a *BatchAPIService) PostMarketingV3CampaignsBatchUpdate(ctx context.Context) ApiPostMarketingV3CampaignsBatchUpdateRequest {
	return ApiPostMarketingV3CampaignsBatchUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BatchResponsePublicCampaign
func (a *BatchAPIService) PostMarketingV3CampaignsBatchUpdateExecute(r ApiPostMarketingV3CampaignsBatchUpdateRequest) (*BatchResponsePublicCampaign, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchResponsePublicCampaign
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchAPIService.PostMarketingV3CampaignsBatchUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/marketing/v3/campaigns/batch/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchInputPublicCampaignBatchUpdateItem == nil {
		return localVarReturnValue, nil, reportError("batchInputPublicCampaignBatchUpdateItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchInputPublicCampaignBatchUpdateItem
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(hubspot.ContextKey).(hubspot.Authorizer); ok {
			auth.Apply(hubspot.AuthorizationRequest{
				QueryParams: localVarQueryParams,
				FormParams:  localVarFormParams,
				Headers:     localVarHeaderParams,
			})
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
